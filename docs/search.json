[
  {
    "objectID": "SciPy analog filter design.html",
    "href": "SciPy analog filter design.html",
    "title": "SciPy analog filter design",
    "section": "",
    "text": "Last update: 27 Aug 2022\nThis notebook describes the use of filter functions in the SciPy library which can be used to design analog filters. Filters are one of the basic building blocks of signal processing. In general terms, filters used for signal processing can be divided into two groups, analog and digital filters. Analog filters, the topic of this notebook, are filters which can be described with linear differential equations and implemented in circuits which operate on continuously varying signals. A digital filter is a system that performs operations on a sampled, discrete-time signal with numerical operations.\nThe first part of this notebook uses SciPy functions to calculate analog filter polynomials based on the classical Butterworth, Chebyshev, Elliptic and Bessel filters. The last section of this notebook walks through a Butterworth filter design and Cauer synthesis of an LC ladder type filter.\nThe Analog filter design can be approached in two ways, by synthesis or by cookbook methods. The SciPy filter design functions fall into the cookbook method of design and stop at circuit realization. SciPy has filter functions that generate the coefficients of the polynomials for Butterworth, Chebyshev, Elliptic and Bessel type filters. And for each type filter, lowpass, highpass, bandpass and bandstop can be specified. SciPy also has filter functions that can evaluate the frequency and transient response of the filters. For the Butterworth, Chebyshev and elliptic type filters there are functions which can estimate the filter order required to meet passband or stopband ripple and attenuation specifications. However there is no Bessel order specification function included in the SciPy libraries.\nThere are several important filter types such as Gaussian, Optimum “L” filter and Linkwitz–Riley filter that are not included in the SciPy signal processing module.\nThe SciPy filter functions provide the electrical engineer with the polynomial coefficients for the filter transfer function. Taking the filter polynomial coefficients and designing an analog filter circuit is not within the scope of what SciPy provides. At this point in the filter design process, the engineer can implement some types of filter networks by using design tables.\nExample calculations are provided below for synthesis of a low pass filter. In the example, I walk through the calculations for filter synthesis directly from the transfer function of a Butterworth lowpass filter. Butterworth lowpass filters are all pole filters with unity numerator in the transfer function which allows the driving point impedance to easly be found and the filter synthesis is accomplished by expanding the \\(Z_{11}\\) with partial fraction expansion.\nNotes on filter synthesis\nCurrently when designs require a ladder prototype, a designer completes the task with the aid of tables. The complex numerical methods involved in generating tables are far from general. Transfer functions with zeros require very complex and filter specific algorithms. The most common approach, Cauer’s algorithm, takes advantage of a particular filter’s properties. Each filter approximation technique needs its own specific algorithm [1]. For transfer functions with zeros, Cauer’s approach produces only one circuit implementation, where many are possible. For transfer functions without zeros, such as Butterworth, Chebyshev and Bessel-Thompson type filters, determining element values involves the classical continued fraction expansion of the input impedance.\nReference\nRelated information DSP references:\nimport numpy as np\nfrom scipy import signal\nfrom sympy import *\nimport matplotlib.pyplot as plt\ninit_printing()"
  },
  {
    "objectID": "SciPy analog filter design.html#lowpass-filter-specification",
    "href": "SciPy analog filter design.html#lowpass-filter-specification",
    "title": "SciPy analog filter design",
    "section": "Lowpass filter specification",
    "text": "Lowpass filter specification\nThe SciPy functions used below can be used to find the order of the filter required based on the passband frequency, stopband frequency and allowable ripple or attenuation.\nSciPy has four functions that return the order of the filter satisfying the users filter specifications, which are in the buttord, cheb1ord, cheb2ord and ellipord. Depending on the type of filter wanted, uncomment the particular function.\n\nfp = 5e3 # passband edge frequency, Hz\ngpass = 3 # The maximum loss in the passband (dB)\n\nfs = 10e3 # stopband edge frequency, Hz\ngstop = 40 # The minimum attenuation in the stopband (dB)\n\n# uncomment filter type to use\nN, Wn = signal.buttord(fp*2*np.pi, fs*2*np.pi, gpass, gstop,analog=True)\n#N, Wn = signal.cheb1ord(fp*2*np.pi, fs*2*np.pi, gpass, gstop,analog=True)\n#N, Wn = signal.cheb2ord(fp*2*np.pi, fs*2*np.pi, gpass, gstop,analog=True)\n#N, Wn = signal.ellipord(fp*2*np.pi, fs*2*np.pi, gpass, gstop,analog=True)\n\nprint('order = {:.0f}, frequency = {:.2f} rad/sec'.format(N,Wn))\n\norder = 7, frequency = 31426.58 rad/sec\n\n\n\nFind filter coefficients\nUncomment the line depending on the type of filter desired. The functions return the numerator (b) and denominator (a), polynomials.\n\nsystem_lp = signal.butter(N, Wn, btype='lowpass', output='ba', analog=True)\n#system_lp = signal.cheby1(N, gpass, Wn, btype='lowpass', output='ba', analog=True)\n#system_lp = signal.cheby2(N, gstop, Wn, btype='lowpass', output='ba', analog=True)\n#system_lp = signal.ellip(N, gpass, gstop, Wn, btype='lowpass', output='ba', analog=True)\n#system_lp = signal.bessel(N, Wn, btype='lowpass', output='ba', analog=True, norm='mag')\n\n\n\nplot filter specification limits\nThe grey areas are the keep out areas specified above.\n\nb, a = system_lp\nw, h = signal.freqs(b, a, 2000) # Compute frequency response of analog filter\nplt.semilogx(w/(2*np.pi), 20 * np.log10(abs(h)))\nplt.title('Filter frequency response and limits')\nplt.xlabel('Frequency, Hz')\nplt.ylabel('Amplitude [dB]')\nplt.grid(which='both', axis='both')\n\nplt.fill([0, fp,  fp,  0], [-gpass, -gpass, -100, -100], '0.9', lw=0) # passband\nplt.fill([fs, fs, 100e9, 100e9], [-gstop, 100, 100, -gstop], '0.9', lw=0) # stopband\nplt.xlim((w[0]/(2*np.pi),100e3))\nplt.ylim((-100,10))\nplt.show()\n\n\n\n\n\n\n\n\n\n\nplot poles and zeros\n\nz, p, k = signal.tf2zpk(system_lp[0],system_lp[1])\n\nplt.plot(np.real(z), np.imag(z), 'ob', markerfacecolor='none')\nplt.plot(np.real(p), np.imag(p), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=2)\nplt.title('Pole / Zero Plot')\nplt.xlabel('Real')\nplt.ylabel('Imaginary')\nplt.grid()\nplt.show()\nprint('k = {:.1f}'.format(k))\n\n\n\n\n\n\n\n\nk = 30274733497480892041442126462976.0\n\n\n\nprint('number of zeros: {:d}'.format(len(z)))\nfor i in z:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 0\n\n\n\nprint('number of poles: {:d}'.format(len(p)))\nfor i in p:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 7\n-1,112.98+4,876.29j Hz\n-1,112.98-4,876.29j Hz\n-3,118.51+3,910.48j Hz\n-3,118.51-3,910.48j Hz\n-5,001.70+0.00j Hz\n-4,506.37+2,170.15j Hz\n-4,506.37-2,170.15j Hz\n\n\n\n\nPlot the Bode magnitude and phase data\nUse the SciPy function bode to plot the magnitude and phase of the filter.\n\n#x = np.linspace(10*2*np.pi, 10e3*2*np.pi, 1000, endpoint=True)\nw, mag, phase = signal.bode(system_lp, w=w)\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nplt.grid(which='both', axis='both')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color=color)  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nPlot the impulse and step response\nUse the SciPy functions impulse2 and step2 to plot the impulse and step response of the system.\n\n# figsize() function to adjust the size\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse2(system_lp,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step2(system_lp,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# space between the plots\n#plt.tight_layout(4)\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\n\nPlot the group delay.\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\nplt.title('Filter group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w)/1e-3,'-',label='group delay')\n#plt.semilogx(w/(2*np.pi), -np.gradient(phase)/w/1e-3,'-',label='phase delay')\nplt.ylabel('Group delay, msec')\nplt.xlabel('Frequency, Hz')\nplt.ylim((0,0.3))\nplt.legend()\nplt.grid()\nplt.show()"
  },
  {
    "objectID": "SciPy analog filter design.html#highpass-filter-specification",
    "href": "SciPy analog filter design.html#highpass-filter-specification",
    "title": "SciPy analog filter design",
    "section": "Highpass filter specification",
    "text": "Highpass filter specification\nUsing the same filter order selection function above, set the passband frequency limit above the stopband frequency limit.\n\nfp = 10e3 # passband edge frequency, Hz\ngpass = 3 # The maximum loss in the passband (dB)\n\nfs = 5e3 # stopband edge frequency, Hz\ngstop = 40 # The minimum attenuation in the stopband (dB)\n\n# uncomment filter type to use\n#N, Wn = signal.buttord(fp*2*np.pi, fs*2*np.pi, gpass, gstop,analog=True)\nN, Wn = signal.cheb1ord(fp*2*np.pi, fs*2*np.pi, gpass, gstop,analog=True)\n#N, Wn = signal.cheb2ord(fp*2*np.pi, fs*2*np.pi, gpass, gstop,analog=True)\n#N, Wn = signal.ellipord(fp*2*np.pi, fs*2*np.pi, gpass, gstop,analog=True)\n\nprint('order = {:.0f}, frequency = {:.2f} rad/sec'.format(N,Wn))\n\norder = 5, frequency = 62831.85 rad/sec\n\n\n\nFind filter coefficients\nUncomment the line depending on the type of filter desired. The functions return the numerator (b) and denominator (a), polynomials.\n\n#system_hp = signal.butter(N, Wn, btype='highpass', output='ba', analog=True)\nsystem_hp = signal.cheby1(N, gpass, Wn, btype='highpass', output='ba', analog=True)\n#system_hp = signal.cheby2(N, gstop, Wn, btype='highpass', output='ba', analog=True)\n#system_hp = signal.ellip(N, gpass, gstop, Wn, btype='highpass', output='ba', analog=True)\n#system_hp = signal.bessel(N, Wn, btype='highpass', output='ba', analog=True, norm='mag')\n\n\n\nplot filter specification limits\nThe grey areas are the keep out areas specified above.\n\nb, a = system_hp\nw, h = signal.freqs(b, a, 2000) # Compute frequency response of analog filter\nplt.semilogx(w/(2*np.pi), 20 * np.log10(abs(h)))\nplt.title('Filter frequency response and limits')\nplt.xlabel('Frequency, Hz')\nplt.ylabel('Amplitude [dB]')\nplt.grid(which='both', axis='both')\n\nplt.fill([100e9, fp,  fp,  100e9], [-gpass, -gpass, -100, -100], '0.9', lw=0) # passband\nplt.fill([fs, fs, 0, 0], [-gstop, 100, 100, -gstop], '0.9', lw=0) # stopband\nplt.xlim((100,100e3))\nplt.ylim((-100,10))\nplt.show()\n\n\n\n\n\n\n\n\n\n\nplot poles and zeros\n\nz, p, k = signal.tf2zpk(system_hp[0],system_hp[1])\n\nplt.plot(np.real(z), np.imag(z), 'ob', markerfacecolor='none')\nplt.plot(np.real(p), np.imag(p), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=2)\nplt.title('Pole / Zero Plot')\nplt.xlabel('Real')\nplt.ylabel('Imaginary')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\nprint('number of zeros: {:d}'.format(len(z)))\nfor i in z:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 5\n0.00 Hz\n0.00 Hz\n0.00 Hz\n0.00 Hz\n0.00 Hz\n\n\n\nprint('number of poles: {:d}'.format(len(p)))\nfor i in p:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 5\n-56,328.42+0.00j Hz\n-3,809.60+15,834.55j Hz\n-3,809.60-15,834.55j Hz\n-586.09+10,319.46j Hz\n-586.09-10,319.46j Hz\n\n\n\n\nPlot the Bode magnitude and phase data\nUse the SciPy function bode to plot the magnitude and phase of the filter.\n\n#x = np.linspace(10*2*np.pi, 10e3*2*np.pi, 1000, endpoint=True)\nw, mag, phase = signal.bode(system_hp, w=w)\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nplt.grid(which='both', axis='both')\nax1.set_xlim((110,100e3))\nax1.set_ylim((-100,10))\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color=color)  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nPlot the impulse and step response\nUse the SciPy functions impulse2 and step2 to plot the impulse and step response of the system.\n\n# figsize() function to adjust the size\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse2(system_hp,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step2(system_hp,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# space between the plots\n#plt.tight_layout(4)\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\n\nPlot the group delay.\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\nplt.title('Filter group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w)/1e-3,'-',label='group delay')\n#plt.semilogx(w/(2*np.pi), -np.gradient(phase)/w/1e-3,'-',label='phase delay')\nplt.xlim((100,100e3))\nplt.ylim((0,0.3))\nplt.ylabel('Group delay, msec')\nplt.xlabel('Frequency, Hz')\nplt.legend()\nplt.grid(which='both', axis='both')\nplt.show()"
  },
  {
    "objectID": "SciPy analog filter design.html#bandpass-filter-specification",
    "href": "SciPy analog filter design.html#bandpass-filter-specification",
    "title": "SciPy analog filter design",
    "section": "Bandpass filter specification",
    "text": "Bandpass filter specification\nUsing the same filter order selection function above, set the passband frequency range as a two element array of band edge frequencies. Set the stopband frequencies as a two element array of band edge frequencies.\n\nf_lower = 8e3 # lower passband edge frequency, Hz\nf_upper = 12e3 # upper passband edge frequency, Hz\n\nwp = [f_lower*2*np.pi,f_upper*2*np.pi] # passband edge frequency, Hz\ngpass = 3 # The maximum loss in the passband (dB)\n\ntransition = 3e3 # amount of transition allowed, Hz\nws = [(f_lower-transition)*2*np.pi,(f_upper+transition)*2*np.pi] # stopband edge frequency, Hz\ngstop = 50 # The minimum attenuation in the stopband (dB)\n\n# uncomment filter type to use\n#N, Wn = signal.buttord(wp, ws, gpass, gstop,analog=True)\n#N, Wn = signal.cheb1ord(wp, ws, gpass, gstop,analog=True)\nN, Wn = signal.cheb2ord(wp, ws, gpass, gstop,analog=True)\n#N, Wn = signal.ellipord(wp, ws, gpass, gstop,analog=True)\n\nprint('order = {:.0f}'.format(N))\n\norder = 5\n\n\n\n#system_bp = signal.butter(N, [f_lower*(2*np.pi),f_upper*(2*np.pi)], btype='bandpass', output='ba', analog=True)\n#system_bp = signal.cheby1(N, gpass, [f_lower*(2*np.pi),f_upper*(2*np.pi)], btype='bandpass', output='ba', analog=True)\n#system_bp = signal.cheby2(N, gstop, [f_lower*(2*np.pi),f_upper*(2*np.pi)], btype='bandpass', output='ba', analog=True)\nsystem_bp = signal.ellip(N, gpass, gstop, [f_lower*(2*np.pi),f_upper*(2*np.pi)], btype='bandpass', output='ba', analog=True)\n#system_bp = signal.bessel(N, [f_lower*(2*np.pi),f_upper*(2*np.pi)], btype='bandpass', output='ba', analog=True, norm='mag')\n\n\nplot filter specification limits\nThe grey areas are the keep out areas specified above.\n\nb, a = system_bp\nw, h = signal.freqs(b, a, 2000) # Compute frequency response of analog filter\nplt.semilogx(w/(2*np.pi), 20 * np.log10(abs(h)))\nplt.title('Filter frequency response and limits')\nplt.xlabel('Frequency, Hz')\nplt.ylabel('Amplitude [dB]')\nplt.grid(which='both', axis='both')\n\nplt.fill([f_lower, f_upper,  f_upper,  f_lower], [-gpass, -gpass, -100, -100], '0.9', lw=0) # passband\nplt.fill([f_lower-transition, f_lower-transition, 0, 0], [-gstop, 100, 100, -gstop], '0.9', lw=0) # stopband\nplt.fill([f_upper+transition, f_upper+transition, 100e9, 100e9], [-gstop, 100, 100, -gstop], '0.9', lw=0) # stopband\nplt.xlim((1e3,1e5))\nplt.ylim((-100,10))\nplt.show()\n\n\n\n\n\n\n\n\n\n\nplot poles and zeros\n\nz, p, k = signal.tf2zpk(system_bp[0],system_bp[1])\n\nplt.plot(np.real(z), np.imag(z), 'ob', markerfacecolor='none')\nplt.plot(np.real(p), np.imag(p), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=2)\nplt.title('Pole / Zero Plot')\nplt.xlabel('Real')\nplt.ylabel('Imaginary')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\nprint('number of zeros: {:d}'.format(len(z)))\nfor i in z:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 9\n0.00+14,344.68j Hz\n0.00-14,344.68j Hz\n-0.00+12,812.15j Hz\n-0.00-12,812.15j Hz\n0.00+7,492.89j Hz\n0.00-7,492.89j Hz\n0.00+6,692.38j Hz\n0.00-6,692.38j Hz\n0.00+0.00j Hz\n\n\n\nprint('number of poles: {:d}'.format(len(p)))\nfor i in p:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 10\n-84.37+11,951.52j Hz\n-84.37-11,951.52j Hz\n-315.11+11,272.78j Hz\n-315.11-11,272.78j Hz\n-444.69+9,787.86j Hz\n-444.69-9,787.86j Hz\n-237.86+8,509.44j Hz\n-237.86-8,509.44j Hz\n-56.70+8,032.05j Hz\n-56.70-8,032.05j Hz\n\n\n\n\nPlot the Bode magnitude and phase data\nUse the SciPy function bode to plot the magnitude and phase of the filter.\n\n#x = np.linspace(10*2*np.pi, 10e3*2*np.pi, 1000, endpoint=True)\nw, mag, phase = signal.bode(system_bp, w=w)\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nplt.grid(which='both', axis='both')\n\nax1.set_xlim((1e3,1e5))\nax1.set_ylim((-100,10))\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color=color)  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-100,10))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nPlot the impulse and step response\nUse the SciPy functions impulse2 and step2 to plot the impulse and step response of the system.\n\n# figsize() function to adjust the size\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse2(system_bp,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step2(system_bp,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# space between the plots\n#plt.tight_layout(4)\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\n\nPlot the group delay.\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\nplt.title('Filter group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w)/1e-3,'-',label='group delay')\n#plt.semilogx(w/(2*np.pi), -np.gradient(phase)/w/1e-3,'-',label='phase delay')\nplt.xlim((1e3,100e3))\nplt.ylim((0,3))\n\nplt.ylabel('Group delay, msec')\nplt.xlabel('Frequency, Hz')\nplt.legend()\nplt.grid(which='both', axis='both')\nplt.show()"
  },
  {
    "objectID": "SciPy analog filter design.html#bandstop-filter-specification",
    "href": "SciPy analog filter design.html#bandstop-filter-specification",
    "title": "SciPy analog filter design",
    "section": "Bandstop filter specification",
    "text": "Bandstop filter specification\nUsing the same filter order selection function above, set the passband frequency range as a two element array of band edge frequencies. Set the stopband frequencies as a two element array of band edge frequencies.\n\nf_lower = 8e3 # lower passband edge frequency, Hz\nf_upper = 10e3 # upper passband edge frequency, Hz\n\nwp = [f_lower*2*np.pi,f_upper*2*np.pi] # passband edge frequency, Hz\ngpass = 1 # The maximum loss in the passband (dB)\n\ntransition = 1e3 # amount of transition allowed\nws = [(f_lower-transition)*2*np.pi,(f_upper+transition)*2*np.pi] # stopband edge frequency, Hz\ngstop = 60 # The minimum attenuation in the stopband (dB)\n\n# uncomment filter type to use\n#N, Wn = signal.buttord(wp, ws, gpass, gstop,analog=True)\n#N, Wn = signal.cheb1ord(wp, ws, gpass, gstop,analog=True)\n#N, Wn = signal.cheb2ord(wp, ws, gpass, gstop,analog=True)\nN, Wn = signal.ellipord(wp, ws, gpass, gstop,analog=True)\n\nprint('order = {:.0f}'.format(N))\n\norder = 5\n\n\n\n#system_bs = signal.butter(N, [f_lower*(2*np.pi),f_upper*(2*np.pi)], btype='bandstop', output='ba', analog=True)\n#system_bs = signal.cheby1(N, gpass, [f_lower*(2*np.pi),f_upper*(2*np.pi)], btype='bandstop', output='ba', analog=True)\n#system_bs = signal.cheby2(N, gstop, [f_lower*(2*np.pi),f_upper*(2*np.pi)], btype='bandstop', output='ba', analog=True)\nsystem_bs = signal.ellip(N, gpass, gstop, [f_lower*(2*np.pi),f_upper*(2*np.pi)], btype='bandstop', output='ba', analog=True)\n#system_bs = signal.bessel(N, [f_lower*(2*np.pi),f_upper*(2*np.pi)], btype='bandstop', output='ba', analog=True, norm='mag')\n\n\nplot filter specification limits\nThe grey areas are the keep out areas specified above.\n\nb, a = system_bs\nw, h = signal.freqs(b, a, 2000) # Compute frequency response of analog filter\nplt.semilogx(w/(2*np.pi), 20 * np.log10(abs(h)))\nplt.title('Filter frequency response and limits')\nplt.xlabel('Frequency, Hz')\nplt.ylabel('Amplitude [dB]')\nplt.grid(which='both', axis='both')\n\nplt.fill([f_lower, f_upper,  f_upper,  f_lower], [-gstop, -gstop, -100, -100], '0.9', lw=0) # passband\nplt.fill([f_lower-transition, f_lower-transition, 0, 0], [-gpass, -100, -100, -gpass], '0.9', lw=0) # stopband\nplt.fill([f_upper+transition, f_upper+transition, 100e9, 100e9], [-gpass, -100, -100, -gpass], '0.9', lw=0) # stopband\nplt.xlim((5e3,2e4))\nplt.ylim((-100,10))\nplt.show()\n\n\n\n\n\n\n\n\n\n\nplot poles and zeros\n\nz, p, k = signal.tf2zpk(system_bs[0],system_bs[1])\n\nplt.plot(np.real(z), np.imag(z), 'ob', markerfacecolor='none')\nplt.plot(np.real(p), np.imag(p), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=2)\nplt.title('Pole / Zero Plot')\nplt.xlabel('Real')\nplt.ylabel('Imaginary')\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\nprint('number of zeros: {:d}'.format(len(z)))\nfor i in z:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 10\n-0.00+9,537.24j Hz\n-0.00-9,537.24j Hz\n0.00+9,328.98j Hz\n0.00-9,328.98j Hz\n-0.00+8,944.27j Hz\n-0.00-8,944.27j Hz\n0.00+8,575.43j Hz\n0.00-8,575.43j Hz\n-0.00+8,388.17j Hz\n-0.00-8,388.17j Hz\n\n\n\nprint('number of poles: {:d}'.format(len(p)))\nfor i in p:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 10\n-3,072.03+8,400.16j Hz\n-3,072.03-8,400.16j Hz\n-535.21+10,375.22j Hz\n-535.21-10,375.22j Hz\n-80.22+10,000.42j Hz\n-80.22-10,000.42j Hz\n-64.17+7,999.15j Hz\n-64.17-7,999.15j Hz\n-396.70+7,690.22j Hz\n-396.70-7,690.22j Hz\n\n\n\n\nPlot the Bode magnitude and phase data\nUse the SciPy function bode to plot the magnitude and phase of the filter.\n\n#x = np.linspace(10*2*np.pi, 10e3*2*np.pi, 1000, endpoint=True)\nw, mag, phase = signal.bode(system_bs, w=w)\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nplt.grid(which='both', axis='both')\n\nax1.set_xlim((5e3,2e4))\nax1.set_ylim((-100,10))\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color=color)  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nPlot the impulse and step response\nUse the SciPy functions impulse2 and step2 to plot the impulse and step response of the system.\n\n# figsize() function to adjust the size\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse2(system_bs,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step2(system_bs,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# space between the plots\n#plt.tight_layout(4)\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\n\nPlot the group delay.\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\nplt.title('Filter group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w)/1e-3,'-',label='group delay')\n#plt.semilogx(w/(2*np.pi), -np.gradient(phase)/w/1e-3,'-',label='phase delay')\nplt.ylabel('Group delay, msec')\nplt.xlabel('Frequency, Hz')\nplt.xlim((1e3,100e3))\nplt.ylim((0,3))\nplt.legend()\nplt.grid(which='both', axis='both')\nplt.show()"
  },
  {
    "objectID": "SciPy analog filter design.html#bessel-lowpass-filter",
    "href": "SciPy analog filter design.html#bessel-lowpass-filter",
    "title": "SciPy analog filter design",
    "section": "Bessel Lowpass filter",
    "text": "Bessel Lowpass filter\nSciPy doesn’t have an order calculation function for the Bessel type filter, so I’ll just pick a filter order and cut off frequency and plot the results. The analog Bessel filter has maximally flat group delay and maximally linear phase response, with very little ringing in the step response.\n\nFind filter coefficients\nThe functions return the numerator (b) and denominator (a), polynomials. Critical frequency normalization parameter is set to norm = ‘mag’, so that the gain magnitude is -3 dB at angular frequency Wn.\n\nfp = 10e3 # passband edge frequency, Hz\nN = 5\nWn = fp*2*np.pi\nsystem_lp = signal.bessel(N, Wn, btype='lowpass', output='ba', analog=True, norm='mag')\n\n\n\nPlot the Bode magnitude and phase data\nUse the SciPy function bode to plot the magnitude and phase of the filter.\n\nw, mag, phase = signal.bode(system_lp, w=w)\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nplt.grid(which='both', axis='both')\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color=color)  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nplot poles and zeros\n\nz, p, k = signal.tf2zpk(system_lp[0],system_lp[1])\n\nplt.plot(np.real(z), np.imag(z), 'ob', markerfacecolor='none')\nplt.plot(np.real(p), np.imag(p), 'xr')\nplt.legend(['Zeros', 'Poles'], loc=2)\nplt.title('Pole / Zero Plot')\nplt.xlabel('Real')\nplt.ylabel('Imaginary')\nplt.grid()\nplt.show()\nprint('k = {:.1f}'.format(k))\n\n\n\n\n\n\n\n\nk = 10980315993618949271977984.0\n\n\n\nprint('number of zeros: {:d}'.format(len(z)))\nfor i in z:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of zeros: 0\n\n\n\nprint('number of poles: {:d}'.format(len(p)))\nfor i in p:\n    print('{:,.2f} Hz'.format(i/(2*np.pi)))\n\nnumber of poles: 5\n-9,576.77+14,711.24j Hz\n-9,576.77-14,711.24j Hz\n-15,023.16+0.00j Hz\n-13,808.77+7,179.10j Hz\n-13,808.77-7,179.10j Hz\n\n\n\n\nPlot the impulse and step response\nUse the SciPy functions impulse2 and step2 to plot the impulse and step response of the system.\n\n# figsize() function to adjust the size\nplt.subplots(1,2,figsize=(15, 5))\n\n# using subplot function and creating\n# plot one\nplt.subplot(1, 2, 1)\n\n# impulse response\nt, y = signal.impulse2(system_lp,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Impulse response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# using subplot function and creating plot two\nplt.subplot(1, 2, 2)\n\nt, y = signal.step2(system_lp,N=500)\nplt.plot(t/1e-3, y)\nplt.title('Step response')\nplt.ylabel('volts')\nplt.xlabel('time, msec')\nplt.grid()\n\n# space between the plots\n#plt.tight_layout(4)\n\n# show plot\nplt.show()\n\n\n\n\n\n\n\n\n\nPlot the group delay.\nThe following python code calculates and plots group delay. Frequency components of a signal are delayed when passed through a circuit and the signal delay will be different for the various frequencies unless the circuit has the property of being linear phase. The delay variation means that signals consisting of multiple frequency components will suffer distortion because these components are not delayed by the same amount of time at the output of the device.\nGroup delay: \\(\\tau _{g}(\\omega )=-\\frac  {d\\phi (\\omega )}{d\\omega }\\)\n\nplt.title('Filter group delay')\nplt.semilogx(w/(2*np.pi), -np.gradient(phase*np.pi/180)/np.gradient(w)/1e-3,'-',label='group delay')\n#plt.semilogx(w/(2*np.pi), -np.gradient(phase)/w/1e-3,'-',label='phase delay')\nplt.ylabel('Group delay, msec')\nplt.xlabel('Frequency, Hz')\nplt.ylim((0,0.05))\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe group delay graph shows that the delay through the filter is constant for frequencies below 10kHz."
  },
  {
    "objectID": "SciPy analog filter design.html#filter-synthesis-example",
    "href": "SciPy analog filter design.html#filter-synthesis-example",
    "title": "SciPy analog filter design",
    "section": "Filter synthesis example",
    "text": "Filter synthesis example\nThe following example walks through the filter design steps for a low pass filter using the SciPy analog filter functions. Specifications for the filter are determined and the order of the filter is calculated. The type of filter selected for implementation is a passive Butterworth filter implemented with capacitors and inductors in a ladder topology. At this point in the design process, filter design tables are used and the normalized element values for a ladder topology are obtained. In this example. I’m going to calculate the normalized values using partial fraction decomposition following the Cauer method.\n\nFilter specification\nThe following filter Specifications are derived from the system requirements. The engineer has determined that a low pass filter is needed and that a passive filter using capacitors and inductors with Butterworth characteristics will meet the system requirements and design goals.\nRequired: Design a low pass filter meeting the following specifications:\n\nLow pass Butterworth filter, implemented with inductors and capacitors\n\n3dB attenuation frequency of 1kHz\n\n20dB minimum stop band attenuation at 2kHz\n\n\\(R_{source}\\) = \\(R_{load}\\) = 1000 ohms\n\nUsing the Butterworth filter order selection function, determine the order of the filter required.\n\nfp = 1e3 # passband edge frequency, Hz\ngpass = 3 # The maximum loss in the passband (dB)\n\nfs = 2e3 # stopband edge frequency, Hz\ngstop = 20 # The minimum attenuation in the stopband (dB)\n\n# uncomment filter type to use\norder, Wn = signal.buttord(fp*2*np.pi, fs*2*np.pi, gpass, gstop,analog=True)\n\nprint('order = {:.0f}, -3dB cutoff frequency = {:.2f} Hz'.format(order,Wn/(2*np.pi)))\n\norder = 4, -3dB cutoff frequency = 1000.59 Hz\n\n\nThe filter order meeting the attenuation requirements is 4.\n\n\nPlot the Bode magnitude and phase data\nUse the SciPy function bode to plot the magnitude and phase of the filter. The gray areas are the keep out areas specified above.\n\nsystem_lp = signal.butter(order, Wn, btype='lowpass', output='ba', analog=True)\n\nw, mag, phase = signal.bode(system_lp, w=w)\n\nfig, ax1 = plt.subplots()\nax1.set_ylabel('magnitude, dB')\nax1.set_xlabel('frequency, Hz')\n\nplt.semilogx(w/(2*np.pi), mag,'-k')    # Bode magnitude plot\n\nax1.tick_params(axis='y')\nplt.grid(which='both', axis='both')\n\nplt.fill([0, fp,  fp,  0], [-gpass, -gpass, -100, -100], '0.9', lw=0) # passband\nplt.fill([fs, fs, 100e9, 100e9], [-gstop, 100, 100, -gstop], '0.9', lw=0) # stopband\nplt.xlim((w[0]/(2*np.pi),10e3))\nplt.ylim((-80,10))\n\n\n# instantiate a second y-axes that shares the same x-axis\nax2 = ax1.twinx()\ncolor = 'tab:blue'\n\nplt.semilogx(w/(2*np.pi), phase,':',color=color)  # Bode phase plot\n\nax2.set_ylabel('phase, deg',color=color)\nax2.tick_params(axis='y', labelcolor=color)\n#ax2.set_ylim((-5,25))\n\nplt.title('Bode plot')\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that a 4th order filter will meet the filter design requirements.\n\n\nSynthesis of filters from polynomials\nFilter design tables contain tables of transfer functions and the component values, so that design by synthesis is not the usual design method. However, in this example, I’m going to walk through the synthesis of the filter from the polynomial. One method of synthesis is to expand the driving point impedance. If the transfer function is all poles, the expression for \\(Z_{11}\\) is:\n\\(Z_{11} = \\frac {D(s)-s^n}{D(s)+s^n}\\)\nwhere\nD(s) is the denominator of the transfer function.\nThe expansion involves successive division and inversion of the ratio of the two polynomials. The final form contains a sequence of terms that are the values for the capacitors and inductors.\nButterworth, Cheby1 and Bessel have poles only, so the expression for \\(Z_{11}\\) given above can be used.\nUsing the SciPy function butter, calculate the numerator and denominator of the transfer function.\n\nnum, den = signal.butter(order, Wn, btype='lowpass', output='ba', analog=True)\n\ns = symbols('s') # declare the variable s\n\n# transfer function\nPoly(num, s)/Poly(den, s)\n\n\\(\\displaystyle \\frac{1.56225057575991 \\cdot 10^{15}}{1.0 s^{4} + 16428.50380806 s^{3} + 134947868.685722 s^{2} + 649341798364.839 s + 1.56225057575991 \\cdot 10^{15}}\\)\n\n\nThe transfer function contains terms that have large exponents, i.e. \\(10^{15}\\). Continuing with the calculations, these terms present a problem in the numerical calculations. The expression for \\(Z_{11}\\) is shown below.\n\nZ11 = (Poly(den, s)-s**order)/(Poly(den, s)+s**order)\nZ11\n\n\\(\\displaystyle \\frac{16428.50380806 s^{3} + 134947868.685722 s^{2} + 649341798364.839 s + 1.56225057575991 \\cdot 10^{15}}{2.0 s^{4} + 16428.50380806 s^{3} + 134947868.685722 s^{2} + 649341798364.839 s + 1.56225057575991 \\cdot 10^{15}}\\)\n\n\nThe filter is realized with the Cauer procedure. This involves removal of poles and zeros from the Z(s) and Y(s) functions in a continued fraction expansion. The SymPy function apart() can be employed to remove the poles at s=0 for \\(Z_{11}\\).\n\napart(1/Z11)\n\n\\(\\displaystyle 0.000121739631518895 s + \\frac{1.0 \\cdot \\left(3.57799435572491 \\cdot 10^{-8} s^{2} + 0.00029390546949122 s + 1.0\\right)}{1.05159211095627 \\cdot 10^{-11} s^{3} + 8.63804249968547 \\cdot 10^{-8} s^{2} + 0.000415645101010116 s + 1.0}\\)\n\n\nThe term, \\(0.000121739631518895s\\) , is the first element value in the filter, with the source resistance of 1 ohm. The value will need to be impedance scaled in the final design. Removing \\(0.000121739631518895s\\) from the expression by subtracting it, we get the following result.\n\napart(1/Z11) - 0.000121739631518895*s\n\n\\(\\displaystyle 3.79470760369927 \\cdot 10^{-19} s + \\frac{1.0 \\cdot \\left(3.57799435572491 \\cdot 10^{-8} s^{2} + 0.00029390546949122 s + 1.0\\right)}{1.05159211095627 \\cdot 10^{-11} s^{3} + 8.63804249968547 \\cdot 10^{-8} s^{2} + 0.000415645101010116 s + 1.0}\\)\n\n\nHere is where we run into a problem with the calculations. There are terms in the result that have small exponents. e.g. \\(10^{-19}\\) and for these terms it is not easy to determine whether these are actually zero or should be carried along in subsequent steps. To avoid this difficulty, the filter natural frequency is normalized to 1 rad/s, which avoids large exponents in the coefficients of the filter polynomial.\nRe-calculate the numerator and denominator polynomials with the normalized frequency of 1 rad/s.\n\norder = 4\nWn = 1\nnum, den = signal.butter(order, Wn, btype='lowpass', output='ba', analog=True)\n\nPoly(num, s)/Poly(den, s)\n\n\\(\\displaystyle \\frac{1.0}{1.0 s^{4} + 2.61312592975275 s^{3} + 3.41421356237309 s^{2} + 2.61312592975275 s + 1.0}\\)\n\n\nNow the driving point impedance for the filter can be written.\n\nZ11 = (Poly(den, s)-s**order)/(Poly(den, s)+s**order)\nZ11\n\n\\(\\displaystyle \\frac{2.61312592975275 s^{3} + 3.41421356237309 s^{2} + 2.61312592975275 s + 1.0}{2.0 s^{4} + 2.61312592975275 s^{3} + 3.41421356237309 s^{2} + 2.61312592975275 s + 1.0}\\)\n\n\n\napart(1/Z11)\n\n\\(\\displaystyle 0.76536686473018 s + \\frac{0.541196100146197 \\cdot \\left(0.765366864730178 s^{2} + 1.0 s + 0.541196100146198\\right)}{0.76536686473018 s^{3} + 1.0 s^{2} + 0.76536686473018 s + 0.292893218813452}\\)\n\n\nThe first value is 0.76536686473018*s, which we can save in an array called normalized_values\n\nnormalized_values = np.zeros(order)\nnormalized_values[0] = 0.76536686473018\n\nNow remove the term \\(0.76536686473018s\\) by subtracting it, we get:\n\nZa = apart(1/Z11) - 0.76536686473018*s\nZa\n\n\\(\\displaystyle - 4.44089209850063 \\cdot 10^{-16} s + \\frac{0.541196100146197 \\cdot \\left(0.765366864730178 s^{2} + 1.0 s + 0.541196100146198\\right)}{0.76536686473018 s^{3} + 1.0 s^{2} + 0.76536686473018 s + 0.292893218813452}\\)\n\n\nUnfortunately, Sympy numerical evaluation can’t tell an expression that is exactly zero apart from one that is merely very small. Using chop=True doesn’t help. I also tried .evalf(20) to get more digits displayed, then tried chop=True, and these still left small values that interfered with the next step.\nThe work around is to copy the terms needed by hand into the next step.\n\n# don't copy the small values\nZa = 0.541196100146197*(0.765366864730178*s**2 + 1.0*s + 0.541196100146198)/(0.76536686473018*s**3 + 1.0*s**2 + 0.76536686473018*s + 0.292893218813452)\nZa\n\n\\(\\displaystyle \\frac{0.414213562373094 s^{2} + 0.541196100146197 s + 0.292893218813453}{0.76536686473018 s^{3} + 1.0 s^{2} + 0.76536686473018 s + 0.292893218813452}\\)\n\n\nContinuing with the partial fraction expansion.\n\napart(1/Za)\n\n\\(\\displaystyle 1.84775906502258 s + \\frac{0.5411961001462 \\cdot \\left(0.76536686473018 s + 1.0\\right)}{0.765366864730178 s^{2} + 1.0 s + 0.541196100146198} - 6.43275715994145 \\cdot 10^{-15}\\)\n\n\nNext value is 1.84775906502258*s, copying the remainder by hand, leaving out small numbers\n\nnormalized_values[1] = 1.84775906502258\n\n\nZb = 0.5411961001462*(0.76536686473018*s + 1.0)/(0.765366864730178*s**2 + 1.0*s + 0.541196100146198)\nZb\n\n\\(\\displaystyle \\frac{0.414213562373098 s + 0.5411961001462}{0.765366864730178 s^{2} + 1.0 s + 0.541196100146198}\\)\n\n\n\napart(1/Zb)\n\n\\(\\displaystyle 1.84775906502256 s + 6.1647256116105 \\cdot 10^{-15} + \\frac{0.99999999999999}{0.76536686473018 s + 1.0}\\)\n\n\nThe next value is 1.84775906502256*s, copying the remainder by hand, leaving out small numbers\n\nnormalized_values[2] = 1.84775906502256\n\n\nZc = 0.99999999999999/(0.76536686473018*s + 1.0)\nZc\n\n\\(\\displaystyle \\frac{0.99999999999999}{0.76536686473018 s + 1.0}\\)\n\n\n\napart(1/Zc)\n\n\\(\\displaystyle 0.765366864730188 s + 1.0\\)\n\n\n\nnormalized_values[3] = 0.765366864730188\n\nNormalized 4th order values are:\n\nnormalized_values\n\narray([0.76536686, 1.84775907, 1.84775907, 0.76536686])\n\n\nThese values agree with the values in Table 11-2 of [2].\n\n\nFrequency and impedance scaling\nNow scale to correct frequency and source resistor value.\nFrequency scaling factor (FSF)\n\\(FSF =  \\frac {desired frequency}{normalized frequency} \\text{ (in rad/s)}\\)\nDiving all reactive elements by FSF\nImpedance scaling factor\n\\(R' = Z \\times R\\)\n\\(L' = \\frac {Z \\times L}{FSF}\\)\n\\(C' = \\frac {C}{Z \\times FSF}\\)\nprimes are values after scaling\n\nFSF = fp*2*np.pi\nZ = 1000\n\n# shunt C\nC1 = normalized_values[0]/(Z*FSF)\nprint('C1 = {:.1f} nF'.format(C1/1e-9))\n# series L\nL1 = Z*normalized_values[1]/FSF\nprint('L1 = {:.1f} mH'.format(L1/1e-3))\n# shunt C\nC2 = normalized_values[2]/(Z*FSF)\nprint('C2 = {:.1f} nF'.format(C2/1e-9))\n# series L\nL2 = Z*normalized_values[3]/FSF\nprint('L2 = {:.1f} mH'.format(L2/1e-3))\n\nC1 = 121.8 nF\nL1 = 294.1 mH\nC2 = 294.1 nF\nL2 = 121.8 mH\n\n\n\n\nLTspice simulation results\nA schematic of the filter was drawn in LTspice and the AC frequency response was simulated.\n\nThe plot below agrees with the Bode plot obtained from SciPy.\n\n\n\nSummary\nThe SciPy filter functions are useful for determining the order of various canonical filter types and generating plots of the frequency and transient responses. The filter polynomial coefficients generated by the filter functions can be used to derive the component values for the capacitors and inductors, but this usually is not easy and SciPy doesn’t have any tools to help with circuit realization."
  },
  {
    "objectID": "Source free series circuit.html",
    "href": "Source free series circuit.html",
    "title": "Source free series circuit",
    "section": "",
    "text": "Last update: 9 May 2022\nIn this notebook, the Python modules SymPy and SciPy are used to solve for currents and voltages in a series R, L and C circuit from the characteristic differential equation.\nA source free series RLC circuit consists of a resistor, capacitor and inductor connected in series with some initial energy stored either in the inductor, capacitor or both. Since the circuit is a single loop, the current flowing around the loop is the same current in each component. Both parallel and series connected circuits are usually presented in electrical circuit analysis classes. The two textbooks I used while in college presented the parallel connected circuit in some detail then kind of glossed over the series connect circuit since it is the dual of the other. The circuit to be analyzed is shown below and was drawn using EasyEDA, the link to the schematic is here.\nNotice that the component values are not shown, nor is there a reference node indicated. Once we write the circuit equation we can do the math symbolically with SymPy. Or we can can solve the differential equation numerically with SciPy. This notebook will look at SymPy and SciPy based solutions for the voltage and currents in the circuit. Initial conditions will be either the voltage on the capacitor or the current in the loop.\nThe following Python libraries are used. NumPy is the fundamental package for scientific computing in Python. SciPy is a collection of mathematical algorithms and convenience functions built on the NumPy extension of Python. Matplotlib is a comprehensive library for creating static, animated, and interactive visualizations in Python. SymPy is a Python library for symbolic mathematics. The init_printing() function will allow the Jupyter notebook to render equations in the best format.\nimport numpy as np\nfrom scipy.integrate import odeint\nimport matplotlib.pyplot as plt\nfrom sympy import *\ninit_printing()"
  },
  {
    "objectID": "Source free series circuit.html#sympy-solution-given-it1-and-it0-at-t0",
    "href": "Source free series circuit.html#sympy-solution-given-it1-and-it0-at-t0",
    "title": "Source free series circuit",
    "section": "SymPy solution, given \\(i(t)=1\\) and \\(i'(t)=0\\) at \\(t=0\\)",
    "text": "SymPy solution, given \\(i(t)=1\\) and \\(i'(t)=0\\) at \\(t=0\\)\nThe current at t=0 is 1 amp and the derivative of the current at t=0 is 0. The initial conditions are needed to solve for the constants as shown later. By use of Kirchhoff’s current law, the current around the loop is the same current flowing in each component and the sum of the potential differences (voltages) around the loop is zero.\nWithin SymPy we can declare variable, t, for time and tell Sympy that t is only positive. Also, we can define the function i(t) as the current in the loop by using the class sympy.core.function.Function.\n\nt = symbols('t',positive=True)  # t &gt; 0\ni = Function('i')(t)\n\nThe symbols L, R and C are used for inductance, resistance and capacitance.\n\nL, R, C = symbols('L R C')\n\nThe voltage current relation of the components in the circuit is defined as follows: The voltage across the resistor is defined by Ohm’s law and is \\(Ri(t)=v(t)\\). An inductor is an electrical component that stores energy in a magnetic field when electric current flows through it. The voltage across the terminals is the derivative of the current, \\(L\\frac{d}{dt}i(t)=v(t)\\) A capacitor is a device that stores energy in an electric field. The terminal voltage is defined by \\(\\frac{1}{C}\\int_0^{\\tau}{i(t)}dt=v(t)\\).\nThe sum of voltages on each of the components around the loop is equal to zero and the equation is written as: \\(L\\frac{d}{dt}i(t)+Ri(t)+\\frac{1}{C}\\int_0^{\\tau}{i(t)}dt=0\\)\nWhen both sides are differentiated with respect to time the result is a homogeneous differential equation. The unknown function is the current i(t) and the solution to the differential equation is the natural response.\nThe variable zero is defined as a constant so that it can be included in the SymPy equation and differentiated without SymPy returning an error.\n\nzero = symbols('zero',constant = True)\n\nloop_voltage is the differential equation that says the sum of the voltages around the loop is equal to zero.\n\nloop_voltage = Eq((L*i.diff(t)+R*i+Integral(i,t)/C).diff(t),(zero).diff(t))\nloop_voltage\n\nEq(L*Derivative(i(t), (t, 2)) + R*Derivative(i(t), t) + i(t)/C, 0)\n\n\nThe SymPy function dsolve is used to find the solution to most kinds of ordinary differential equations and systems of ordinary differential equations. Except for the evaluation of the constants, C1 and C2, the current in the loop as a function of time is shown below.\n\nloop_current = dsolve(loop_voltage,i)\nloop_current\n\n\\[i{\\left (t \\right )} = C_{1} e^{\\frac{t \\left(- R - \\sqrt{R^{2} - \\frac{4 L}{C}}\\right)}{2 L}} + C_{2} e^{\\frac{t \\left(- R + \\sqrt{R^{2} - \\frac{4 L}{C}}\\right)}{2 L}}\\]\n\n\nAt t=0, the loop current is 1 amp as stated above. The following line of Python code evaluates the right hand side (using args[1]) of the loop current equation at time zero (subs({t:0})) and equates it to 1 amp.\n\nEq(loop_current.args[1].subs({t:0}),1)\n\n\\[C_{1} + C_{2} = 1\\]\n\n\nThe derivative of the loop current is evaluated at t=0 and the result is set equal to zero. This is written as an equation using the following python code.\n\nEq(loop_current.args[1].diff(t).subs({t:0}),0)\n\n\\[\\frac{C_{1} \\left(- R - \\sqrt{R^{2} - \\frac{4 L}{C}}\\right)}{2 L} + \\frac{C_{2} \\left(- R + \\sqrt{R^{2} - \\frac{4 L}{C}}\\right)}{2 L} = 0\\]\n\n\nThe symbols C1 and C2 are declared for the constants in the solution for the differential equation and evaluation of the loop current equation at t=0 and the derivative at t=0 are put into matrix form as shown below.\n\nC1, C2 = symbols('C1 C2')\nMatrix(\n    [[Eq(loop_current.args[1].subs({t:0}),1)],\n    [Eq(loop_current.args[1].diff(t).subs({t:0}),0)]])\n\n\\[\\left[\\begin{matrix}C_{1} + C_{2} = 1\\\\\\frac{C_{1} \\left(- R - \\sqrt{R^{2} - \\frac{4 L}{C}}\\right)}{2 L} + \\frac{C_{2} \\left(- R + \\sqrt{R^{2} - \\frac{4 L}{C}}\\right)}{2 L} = 0\\end{matrix}\\right]\\]\n\n\nThe Sympy function solve can be used to find a solution to these two equations and two unknowns.\n\nconst = solve(Matrix(\n    [[Eq(loop_current.args[1].subs({t:0}),1)],\n    [Eq(loop_current.args[1].diff(t).subs({t:0}),0)]]),[C1, C2])\n\nconst\n\n\\[\\left \\{ C_{1} : - \\frac{R}{2 \\sqrt{R^{2} - \\frac{4 L}{C}}} + \\frac{1}{2}, \\quad C_{2} : \\frac{R}{2 \\sqrt{R^{2} - \\frac{4 L}{C}}} + \\frac{1}{2}\\right \\}\\]\n\n\nSubstituting the constants back into the loop current equation we get the solution in symbolic form.\n\nloop_current.subs(const)\n\n\\[i{\\left (t \\right )} = \\left(- \\frac{R}{2 \\sqrt{R^{2} - \\frac{4 L}{C}}} + \\frac{1}{2}\\right) e^{\\frac{t \\left(- R - \\sqrt{R^{2} - \\frac{4 L}{C}}\\right)}{2 L}} + \\left(\\frac{R}{2 \\sqrt{R^{2} - \\frac{4 L}{C}}} + \\frac{1}{2}\\right) e^{\\frac{t \\left(- R + \\sqrt{R^{2} - \\frac{4 L}{C}}\\right)}{2 L}}\\]\n\n\nGoing future requires some numeric values for R, L and C. If the values of R, L and C produce a negative square root, then the natural response is called underdamped because the current waveform is a decaying sinusoidal wave. Values of R, L and C that don’t have an imaginary exponent produce a natural response that is called overdamped. Examples of the underdamped and overdamped responses are shown below.\nEngineering text books usually define the resonant frequency and the damping coefficient, then define the over, under and critically damped conditions in terms of the resonant frequency and the damping coefficient as follows:\nResonant frequency: \\(\\omega_o=\\frac {1} {\\sqrt{LC}}\\), the frequency at which a system tends to oscillate in the absence of a driving force.\nDamping coefficient: \\(\\alpha = \\frac {R}{2RL}\\), a measure describing how oscillations in a system decay.\nOverdamped: \\(\\alpha &gt; \\omega_o\\), the response is the sum of two decaying exponentials with no oscillation.\nCritically damped: \\(\\alpha = \\omega_o\\), the response sits on the border between the overdamped and underdamped cases.\nUnder damped: \\(\\alpha &lt; \\omega_o\\), the response is a decaying sinusoidal wave and has a frequency of \\(\\omega_d = \\sqrt{\\omega_o^2 + \\alpha^2}\\)"
  },
  {
    "objectID": "Source free series circuit.html#over-damped-response",
    "href": "Source free series circuit.html#over-damped-response",
    "title": "Source free series circuit",
    "section": "Over damped response",
    "text": "Over damped response\nThe condition for the overdamped response is satisfied by, \\(\\frac{R}{2L}&gt;\\frac{1}{\\sqrt{LC}}\\). Choosing R=6, L=4 and C=1 will produce an overdamped response. The element values are assigned to the symbols with the dictionary data type, which are used to store data values in key:value pairs.\n\nele_values = {R:6,L:4,C:1}\n\nUsing the SymPy operator evalf() to convert to floating point.\n\nalpha = (R/(2*L)).subs(ele_values)\nprint('alpha = {:.2f}'.format(alpha.evalf()))\n\nw_o = (1/sqrt(L*C)).subs(ele_values)\nprint('natural frequency = {:.2f}, rad/s'.format(w_o.evalf()))\n\nprint('alpha &gt; natural frequency = {:s}'.format(str(alpha &gt; w_o)))\n\nalpha = 0.75\nnatural frequency = 0.50, rad/s\nalpha &gt; natural frequency = True\n\n\nSubstituting the constants and the component values we get the following equation.\n\nloop_current.subs(const).subs(ele_values)\n\n\\[i{\\left (t \\right )} = \\left(- \\frac{3 \\sqrt{5}}{10} + \\frac{1}{2}\\right) e^{\\frac{t \\left(-6 - 2 \\sqrt{5}\\right)}{8}} + \\left(\\frac{1}{2} + \\frac{3 \\sqrt{5}}{10}\\right) e^{\\frac{t \\left(-6 + 2 \\sqrt{5}\\right)}{8}}\\]\n\n\nThe module lambdify is used to transform SymPy expressions to lambda functions which can be used to calculate numerical values.\n\nfunc_current = lambdify(t, loop_current.subs(const).subs(ele_values).args[1]) \n\nThe plot below shows the loop current in amps versus time. The response is a smoothly decreasing function from the initial condition of 1 amp. The lambdify function returns complex numbers and both real and imaginary parts are plotted. The imaginary values are zero.\n\nx = np.linspace(0, 20, 2000, endpoint=True)\n#dx = 0.1\n#x = np.arange(0,20,dx)\n\nplt.title('Loop current vs time')\n\n#plt.plot(x, func_current(x))\nplt.plot(x, np.real(func_current(x)),label='Re i(t)')\nplt.plot(x, np.imag(func_current(x)),label='Im i(t)')\n\nplt.ylabel('i(t), amps')\nplt.xlabel('time, sec')\nplt.ylim((-0.1,1.1))\nplt.xlim((-1,20))\nplt.legend()\nplt.grid()\nplt.show()"
  },
  {
    "objectID": "Source free series circuit.html#under-damped-response",
    "href": "Source free series circuit.html#under-damped-response",
    "title": "Source free series circuit",
    "section": "Under damped response",
    "text": "Under damped response\nChoosing R=0.5, L=1 and C=0.1 will produce an under damped response.\n\\(\\frac{R}{2L}&lt;\\frac{1}{\\sqrt{LC}}\\)\nThe component values are assigned below.\n\nele_values = {R:0.5,L:1.0,C:0.1}\n\n\nalpha = (R/(2*L)).subs(ele_values)\nprint('alpha = {:.2f}'.format(alpha.evalf()))\n\nw_o = (1/sqrt(L*C)).subs(ele_values)\nprint('natural frequency = {:.2f}, rad/s'.format(w_o.evalf()))\n\nprint('alpha &lt; natural frequency = {:s}'.format(str(alpha &lt; w_o)))\n\nalpha = 0.25\nnatural frequency = 3.16, rad/s\nalpha &lt; natural frequency = True\n\n\nSubstitute the constants and component values we get the following equation.\n\nloop_current.subs(const).subs(ele_values)\n\n\\[i{\\left (t \\right )} = \\left(\\frac{1}{2} + 0.0396525792859072 i\\right) e^{0.5 t \\left(-0.5 - 6.30476010645925 i\\right)} + \\left(\\frac{1}{2} - 0.0396525792859072 i\\right) e^{0.5 t \\left(-0.5 + 6.30476010645925 i\\right)}\\]\n\n\n\nfunc_current = lambdify(t, loop_current.subs(const).subs(ele_values).args[1]) \n\nThe plot below shows the loop current in amps versus time. The response is a decaying sinusoidal waveform from the initial condition of 1 amp. The lambdify function returns complex numbers and both real and imaginary parts are plotted. The imaginary values are zero.\n\nplt.title('Loop current vs time')\n\nplt.plot(x, np.real(func_current(x)),label='Re i(t)')\nplt.plot(x, np.imag(func_current(x)),label='Im i(t)')\n\nplt.ylabel('i(t), amps')\nplt.xlabel('time, sec')\nplt.ylim((-1.1,1.1))\nplt.xlim((-1,20))\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above was verified by comparing the results with LTspice simulation of the same circuit."
  },
  {
    "objectID": "Source free series circuit.html#solving-for-other-circuit-variables",
    "href": "Source free series circuit.html#solving-for-other-circuit-variables",
    "title": "Source free series circuit",
    "section": "Solving for other circuit variables",
    "text": "Solving for other circuit variables\nThe voltages across each of the components can be computed since the current has been solved for. The initial condition for the current at t=0 is 1 amp. Also the derivative of the current at t=0 is 0, which will be used when calculating the voltage across the inductor. At t=0, the current flowing through the capacitor is 1 amp, which causes a voltage across the resistor of 0.5 volts.\nThe voltages around the loop must sum to zero, so this means one of the components must have a negative voltage with respect to the others for the sum to be zero. Since the inductor’s voltage is related to the derivative of the current and at t=0, i’(0)=0, the inductor has no voltage across its terminals. The capacitor can have an initial voltage on its terminals, which has not been defined, but since the voltages must sum to zero, the initial voltage on the capacitor must be -0.5 volts.\n\n# voltage across the resistor\nR_voltage = ele_values[R]*np.real(func_current(x))\n\nplt.title('Voltage across R')\nplt.plot(x,R_voltage)\n\nplt.ylabel('Volts')\nplt.xlabel('time, sec')\n\n#plt.ylim((-1,1))\nplt.xlim((-0.5,20))\nplt.yticks(np.arange(-0.5, 0.75, 0.25))\n#plt.xticks(np.arange(0, 20+1, 2.0))\n#plt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nVoltage across the inductor is calculated by: \\(L\\frac{d}{dt}i(t)=v(t)\\) There is no initial voltage because i’(0)=0.\nNumPy does not provide general functionality to compute derivatives so we will use the gradient function and supply the spacing between the samples.\n\nL_voltage = ele_values[L]*np.gradient(np.real(func_current(x)),x[1])\nL_voltage[0] = 0 # make v(0) = 0 \n\nplt.title('Voltage across L')\nplt.plot(x, L_voltage)\n\nplt.ylabel('Volts')\nplt.xlabel('time, sec')\n\nplt.ylim((-3,3))\nplt.xlim((-0.5,20))\n#plt.yticks(np.arange(-2.5, 3.1, 0.5))\n#plt.xticks(np.arange(0, 20+1, 2.0))\n#plt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe voltage across the capacitor is given by: \\(\\frac{1}{C}\\int_0^{\\tau}{i(t)}dt+v(0)=v(t)\\). As described above, \\(v(0)=-0.5\\)\nThe code below calculates the integral of the current using the numpy function trapz, which uses the composite trapezoidal rule to approximate integration.\n\nintegral_of_current = np.zeros(len(x))\nfor k in range(len(x)):\n    integral_of_current[k] = np.trapz(np.real(func_current(x[0:k+1])),x=None,dx=x[1])\n\nC_voltage = integral_of_current/ele_values[C] -  ele_values[R]*np.real(func_current(0))\n\nplt.title('Voltage across C')\n\nplt.plot(x, C_voltage )\n\nplt.ylabel('volts')\nplt.xlabel('time, sec')\nplt.ylim((-3,3))\nplt.xlim((-0.5,20))\n#plt.yticks(np.arange(-2.5, 3, .5))\n#plt.xticks(np.arange(0, 20+1, 2.0))\n#plt.legend()\nplt.grid()\nplt.show()"
  },
  {
    "objectID": "Source free series circuit.html#sum-the-voltages-around-the-loop",
    "href": "Source free series circuit.html#sum-the-voltages-around-the-loop",
    "title": "Source free series circuit",
    "section": "Sum the voltages around the loop",
    "text": "Sum the voltages around the loop\nTo check the results we can sum the voltages around the loop and the result should be zero, or approximately zero.\n\nplt.title('Sum of Voltage around the loop')\n\nplt.plot(x, R_voltage + L_voltage + C_voltage)\n\nplt.ylabel('volts')\nplt.xlabel('time, sec')\n#plt.ylim((-.1,.1))\nplt.xlim((-1,10))\n#plt.yticks(np.arange(-2.5, 3, .5))\n#plt.xticks(np.arange(0, 20+1, 2.0))\n#plt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe sum of the voltages are almost zero, but not quite, probably because of round off errors in the integration and differentiation. Investigation of the error could be the subject of a different effort or maybe a future update to this notebook."
  },
  {
    "objectID": "Source free series circuit.html#scipy-solution",
    "href": "Source free series circuit.html#scipy-solution",
    "title": "Source free series circuit",
    "section": "SciPy solution",
    "text": "SciPy solution\nUsing SciPy to numerically solve for the current in the series circuit. The differential equation needs to be re-formulated because SciPy can only solve first order equations. The differential equation \\(𝐿\\frac{𝑑^2}{𝑑𝑡^2}𝑖(𝑡)+𝑅\\frac{𝑑}{𝑑𝑡}𝑖(𝑡)+\\frac{𝑖(𝑡)}{𝐶}=0\\) is rewritten by multiplying the terms by C, \\(𝐿C\\frac{𝑑^2}{𝑑𝑡^2}𝑖(𝑡)+𝑅C\\frac{𝑑}{𝑑𝑡}𝑖(𝑡)+𝑖(𝑡)=0\\).\nThe shorthand notation for the derivative of the current is used: \\(𝐿Ci''+𝑅Ci'+𝑖=0\\).\nRearrange the equation to put the second derivative of i on the left hand side: \\(i''=\\frac {-Ri'-i}{CL}\\)\nA new variable \\(z\\) is introduced \\(z = i'\\) along with its derivative \\(z'=i''\\)\nSubstituting the expression for z and z’ back into the original equation, we get the following two equations.\n\\(z' =\\frac {-RCz-i}{CL}\\)\n\\(z=i'\\)\nThese are then written into a Python function called circuit_model.\n\ndef circuit_model(I, t):\n    R = 0.5 # resistor value\n    L = 1.0 # inductor value\n    C = 0.1 # capacitor value\n    i = I[0] # the current variable\n    z = I[1] # \n    didt = z # the equation from above\n    dzdt = (-C*R*z-i)/(L*C) # \n    return [didt, dzdt]\n\nThe initial conditions\n\nt0 = 0 # t starts at zero\ni0 = 1 # current at t=0\nz0 = 0\nI0 = [i0, z0]\n\nUsing the SciPy function scipy.integrate.odeint to solve the differential equation. Odeint computes the derivative of the function at t.\n\nt = np.linspace(0, 20,num=2000)\nloop_current = odeint(circuit_model, I0, t)\n\nplt.title('loop current')\nplt.plot(t, loop_current[:,0], label='i(t)')\nplt.ylabel('current, amps')\nplt.xlabel('time, sec')\nplt.ylim((-1,1.5))\nplt.xlim((-1,20))\n#plt.yticks(np.arange(-2.5, 3, .5))\n#plt.xticks(np.arange(0, 20+1, 2.0))\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe SciPy solution is compared against the SymPy solution by taking the difference in the calculated loop current. The difference is shown below.\n\nplt.title('SymPy solution minus SciPy solution for current')\nplt.plot(t, (loop_current[:,0]-np.real(func_current(x)))*1e6)\nplt.ylabel('current, micro amps')\nplt.xlabel('time, sec')\nplt.ylim((-0.1,0.1))\nplt.xlim((0,20))\n#plt.yticks(np.arange(-0.1, 0.1, .05))\n#plt.xticks(np.arange(0, 20+1, 2.0))\n#plt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe difference between the computed currents is less than 0.1 micro amps, which is probably small enough to ignore."
  },
  {
    "objectID": "Source free series circuit.html#sympy-solution-given-vct1-and-vct0-at-t0",
    "href": "Source free series circuit.html#sympy-solution-given-vct1-and-vct0-at-t0",
    "title": "Source free series circuit",
    "section": "SymPy solution, given \\(Vc(t)=1\\) and \\(Vc'(t)=0\\) at \\(t=0\\)",
    "text": "SymPy solution, given \\(Vc(t)=1\\) and \\(Vc'(t)=0\\) at \\(t=0\\)\nIf the initial condition for the series circuit has the voltage on the capacitor given, then the circuit equations can be solved as follows. Declare the variable, t, for time and define it to be positive. Define a function, v, for the voltage across the capacitor and make it time dependent.\n\nt = symbols('t',positive=True)  # t &gt; 0\nv = Function('v')(t)\n\nThe symbols L, R and C used for inductance, resistance and capacitance were declared above.\nThe current through the capacitor is equal to the derivative of the voltage, \\(C\\frac{d}{dt}v(t)=i(t)\\). The voltage across the series L and R is \\(L\\frac{d}{dt}i(t)+Ri(t)=-v(t)\\), where v(t) is the voltage across the capacitor. Since the current is the same in the loop, the capacitor current can be substituted in the equation to give: \\(CL\\frac{d^2}{dt^2}v(t)+CR\\frac{d}{dt}v(t)=-v(t)\\)\nThe right hand side is negative since the voltage around the loop must sum to zero. The equation can be expressed in SymPy as:\n\nEq(L*C*v.diff(t,t) + R*((C*v.diff(t))),  -v)\n\n\\[C L \\frac{d^{2}}{d t^{2}} v{\\left (t \\right )} + C R \\frac{d}{d t} v{\\left (t \\right )} = - v{\\left (t \\right )}\\]\n\n\nUsing the SymPy function dsolve to find the capacitor voltage, we get:\n\nC_voltage = dsolve(Eq(L*C*v.diff(t,t) + R*C*v.diff(t), -v))\nC_voltage\n\n\\[v{\\left (t \\right )} = C_{1} e^{\\frac{t \\left(- R - \\frac{\\sqrt{C \\left(C R^{2} - 4 L\\right)}}{C}\\right)}{2 L}} + C_{2} e^{\\frac{t \\left(- R + \\frac{\\sqrt{C \\left(C R^{2} - 4 L\\right)}}{C}\\right)}{2 L}}\\]\n\n\nat t = 0, voltage on capacitor is 1\n\nEq(C_voltage.args[1].subs({t:0}),1)\n\n\\[C_{1} + C_{2} = 1\\]\n\n\nderivative of the capacitor voltage is 0\n\nEq(C_voltage.args[1].diff(t).subs({t:0}),0)\n\n\\[\\frac{C_{1} \\left(- R - \\frac{\\sqrt{C \\left(C R^{2} - 4 L\\right)}}{C}\\right)}{2 L} + \\frac{C_{2} \\left(- R + \\frac{\\sqrt{C \\left(C R^{2} - 4 L\\right)}}{C}\\right)}{2 L} = 0\\]\n\n\nUsing the two initial conditions, the constants can be solved for.\n\nconst = solve(Matrix(\n    [[Eq(C_voltage.args[1].subs({t:0}),1)],\n    [Eq(C_voltage.args[1].diff(t).subs({t:0}),0)]]),[C1, C2])\nconst\n\n\\[\\left \\{ C_{1} : - \\frac{C R}{2 \\sqrt{C^{2} R^{2} - 4 C L}} + \\frac{1}{2}, \\quad C_{2} : \\frac{C R}{2 \\sqrt{C^{2} R^{2} - 4 C L}} + \\frac{1}{2}\\right \\}\\]"
  },
  {
    "objectID": "Source free series circuit.html#under-damped-response-1",
    "href": "Source free series circuit.html#under-damped-response-1",
    "title": "Source free series circuit",
    "section": "Under damped response",
    "text": "Under damped response\nAs described above the underdamped case is defined as \\(\\frac {R}{2RL} &gt; \\frac {1} {\\sqrt{LC}}\\). Choosing R=0.5, L=1 and C=0.1 will produce an under damped response.\nEvaluating the equation numerically, the voltage on the capacitor is:\n\nC_voltage.subs(const).subs(ele_values)\n\n\\[v{\\left (t \\right )} = \\left(\\frac{1}{2} + 0.0396525792859072 i\\right) e^{0.5 t \\left(-0.5 - 6.30476010645925 i\\right)} + \\left(\\frac{1}{2} - 0.0396525792859072 i\\right) e^{0.5 t \\left(-0.5 + 6.30476010645925 i\\right)}\\]\n\n\nUsing the SymPy function lambdify to turn the expression into a function:\n\nfunc_C_voltage = lambdify(t, C_voltage.subs(const).subs(ele_values).args[1]) \n\nFind the current in C by differentiating the voltage, \\(C\\frac{d}{dt}v(t)=i(t)\\)\n\nx = np.linspace(0, 20, 2000, endpoint=True)\ncurrent_in_C = ele_values[C]*np.gradient(np.real(func_C_voltage(x)),x[1])\ncurrent_in_C[0] = 0 # set the current in the capacitor to 0 at t=0\n\nFind the voltage across the resistor, \\(Ri(t)\\) and the voltage across the inductor, \\(L\\frac{d}{dt}i(t)\\). At t=0, there is no current flowing, so the initial voltage on the resistor is zero. The initial voltage on the capacitor of 1 volt, must be balanced by an initial voltage on the inductor.\n\nR_voltage = ele_values[R]*current_in_C\nL_voltage = ele_values[L]*np.gradient(current_in_C,x[1])\nL_voltage[0] = -1 # set the voltage on the inductor at t=0\n\n\nplt.title('volts across C')\n\nplt.plot(x, np.real(func_C_voltage(x)),label='volts across C')\nplt.plot(x, current_in_C, label='current in C')\nplt.plot(x, R_voltage, label='volts across R')\nplt.plot(x, L_voltage, label='volts across L')\n\nplt.ylabel('voltage')\nplt.xlabel('time, sec')\n#plt.ylim((-3,3))\nplt.xlim((0,5))\n#plt.yticks(np.arange(-2.5, 3, .5))\n#plt.xticks(np.arange(0, 20+1, 2.0))\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nChecking to see that the voltage sum around the loop is zero.\n\nplt.title('Sum of the component voltages')\n\nplt.plot(x, np.real(func_C_voltage(x)) + R_voltage + L_voltage)\n\nplt.ylabel('voltage')\nplt.xlabel('time, sec')\n#plt.ylim((-3,3))\nplt.xlim((-1,20))\n#plt.yticks(np.arange(-2.5, 3, .5))\n#plt.xticks(np.arange(0, 20+1, 2.0))\n#plt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nThe sum of the voltages almost is zero. Investigating the source of the error is a different topic."
  },
  {
    "objectID": "Source free series circuit.html#summary",
    "href": "Source free series circuit.html#summary",
    "title": "Source free series circuit",
    "section": "Summary",
    "text": "Summary\nThis notebook walked through the steps of using SymPy and SciPy to solve a 2nd order ordinary differential equation for a series connected LRC circuit. Both symbolic and numerical solutions were generated and the results were plotted. The SymPy and SciPy libraries are very versatile and make these types of computations very easy.\nElectrical engineers don’t normally solve circuit analysis problems by writing differential equations and solving them, Laplace transforms are used instead.\n\nLaplace transform\nThe Laplace transform is named after Pierre-Simon Laplace. Skipping the mathematical justification, engineers can analyze circuits by using a transform that converts a function of a real variable t, to a function of a complex variable s. The resistors, capacitors and inductors can be replaced by the transformed Laplace elements. Replace the resistors in the circuit with \\(RI(s)\\), replace the inductors with \\(L[I(s)s+i(0)]\\) and the capacitors with \\([\\frac{I(s)}{sC} + \\frac{v(0)}{s}]\\)\nDefining the SymPy variable for time and the complex variable s.\n\ns = symbols('s')\nt = symbols('t',positive=True)  # t &gt; 0\n\nThe symbols L, R and C are used for inductance, resistance and capacitance. L_i_zero (also i(0)) is the initial current through the inductor and C_v_zero (also v(0)) is the initial voltage on the capacitor. The symbol s is used for the Laplace variable.\n\nL, R, C, L_i_zero, C_v_zero, s= symbols('L R C L_i_zero C_v_zero s')\n\n\n\nSeries circuit\nReplacing each element with the transformed Laplace elements, write the sum of the voltages around the loop:\n\\(LsI(s)-Li(0)+RI(s)+\\frac{I(s)}{sC}+\\frac{v(0)}{s}=0\\)\nCollecting the \\(I(s)\\) terms on the right:\n\\(I(s)=\\frac{i(0)}{Ls+R+\\frac{1}{Cs}+\\frac{v(0)}{s}}\\)\nDefining the element values:\n\nele_values = {R:0.5,L:1.0,C:0.1,L_i_zero:1,C_v_zero:0}\n\nWhere L_i_zero is the initial current in the inductor and C_v_zero is the initial voltage on the capacitor, we can write the expression in SymPy:\n\nexp = L_i_zero/(L*s+R+1/(C*s)+C_v_zero/s)\nexp\n\n\\[\\frac{L_{i zero}}{\\frac{C_{v zero}}{s} + L s + R + \\frac{1}{C s}}\\]\n\n\nThe symbolic solution inverse transform takes a long time and I had to interrupt the kernel and kill the process.\n\n#inverse_laplace_transform(exp, s, t)\n\nDoing the inverse transform numerically is much quicker.\n\ninverse_laplace_transform(exp.subs(ele_values), s, t)\n\n\\[1.0 \\left(- 0.0793051585718144 \\sin{\\left (3.15238005322962 t \\right )} + 1.0 \\cos{\\left (3.15238005322962 t \\right )}\\right) e^{- 0.25 t}\\]\n\n\n\nfunc_current1 = lambdify(t, inverse_laplace_transform(exp.subs(ele_values), s, t)) \n\nThe plot below shows the loop current in amps versus time.\n\n#x = np.linspace(0, 20, 2000, endpoint=True)\nplt.title('Loop current vs time')\n\nplt.plot(x, np.real(func_current1(x)),label='Re i(t)')\nplt.plot(x, np.imag(func_current1(x)),label='Im i(t)')\n\nplt.ylabel('i(t), amps')\nplt.xlabel('time, sec')\nplt.ylim((-1.1,1.1))\nplt.xlim((-1,20))\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\nNearly the same result obtained by solving the differential equations above. The difference is plotted below. Investigating the source of the error is a different topic.\n\nplt.title('SymPy solution minus Laplace solution for current')\nplt.plot(x, (np.real(func_current1(x))-np.real(func_current(x)))*1e0)\nplt.ylabel('current, amps')\nplt.xlabel('time, sec')\n#plt.ylim((-0.1,0.1))\n#plt.xlim((0,20))\n#plt.yticks(np.arange(-0.1, 0.1, .05))\n#plt.xticks(np.arange(0, 20+1, 2.0))\n#plt.legend()\nplt.grid()\nplt.show()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "A collection of Jupyter Notebooks",
    "section": "",
    "text": "Note\n\n\n\nLast update: 21 Jan 2024\n\nThese pages are draft copies and only half baked.\nMany sections are still under construction.\nOnly preliminary files have been posted to github.\nSpelling and grammar checks have not been completed.\nThe pages are posted for testing only."
  },
  {
    "objectID": "index.html#electrical-engineering",
    "href": "index.html#electrical-engineering",
    "title": "A collection of Jupyter Notebooks",
    "section": "Electrical engineering",
    "text": "Electrical engineering\nThe following notebooks cover various topics in electrical engineering. Electrical engineering is an engineering discipline concerned with electricity, electronics and electromagnetism. My intrest is in circuits and systems, which covers theory, analysis, design, practical implementations of circuits and the application of circuit techniques to systems and to signal processing.\n\nCircuit Analysis\n\nSymbolic Modified Nodal Analysis using Python\nThe link above is to the online version of my book: Symbolic Modified Nodal Analysis using Python. Symbolic circuit analysis is a circuit analysis method that derives network equations with the circuit elements represented by symbols.\n\n\nSource free series circuit\nIn this notebook, the Python modules SymPy and SciPy are used to solve for currents and voltages in a series R, L and C circuit from the characteristic differential equation. A source free series RLC circuit consists of a resistor, capacitor and inductor connected in series with some initial energy stored either in the inductor, capacitor or both. Since the circuit is a single loop, the current flowing around the loop is the same current in each component. Both parallel and series connected circuits are usually presented in electrical circuit analysis classes. The two textbooks I used while in college presented the parallel connected circuit in some detail then kind of glossed over the series connect circuit since it is the dual of the other. The circuit to be analyzed is shown below and was drawn using EasyEDA, the link to the schematic is here.\n\n\n\nFilter synthesis\n\nSciPy analog filter design\nThis notebook describes the use of filter functions in the SciPy library which can be used to design analog filters. Filters are one of the basic building blocks of signal processing. In general terms, filters used for signal processing can be divided into two groups, analog and digital filters. Analog filters, the topic of this notebook, are filters which can be described with linear differential equations and implemented in circuits which operate on continuously varying signals. A digital filter is a system that performs operations on a sampled, discrete-time signal with numerical operations. The first part of this notebook uses SciPy functions to calculate analog filter polynomials based on the classical Butterworth, Chebyshev, Elliptic and Bessel filters. The last section of this notebook walks through a Butterworth filter design and Cauer synthesis of an LC ladder type filter.\nFuture topics\n\nPolynimial implementations\nActive implementations\n\nState variable filter design\n\nBi-Quad LP, HP, BP, BR\n\nSallen Key active filter\n\nCrystal filters\nHelical filters\nWave guide filters\n\n\n\n\nAnalog Circuits\nAnalog electronic circuits are those in which current or voltage vary continuously with time to correspond to the information being represented. The basic components of analog circuits are wires, resistors, capacitors, inductors, diodes, and transistors.\nFuture topics\n\nsemiconductors\nDiodes\nTransistors\nAmplifiers\nWave forming circuits\nPower electronics\nAnalog computing\nVacuum tube models for SPICE\n\n\n\nElectric Machines & Electromechanics\n\nOvershot waterwheel hydroelectric power system analysis\nThis notebook examines the construction of a small hydroelectric system built by Michael Loftis, a YouTuber, real estate and insurance broker, who had a hydro system built for his off-grid cabin on 50 acres in the Ozark Mountains. The cabin and hydro system are unique and look really interesting. The cabin is available for rent as an AirBnB and is located in Thornfield, Missouri. The cabin is now advertised as having some solar panels with a gas powered generator to supplement the solar. Michael’s hydroelectric project looked really interesting and I was curious about the technical details. In the YouTube videos, Did we MAKE HYDRO POWER Using Our Waterwheel for Self Reliant Off Grid Living? and Possible Hydro Power Solutions for our Off Grid Cabin? A BIG THANKS TO YOU!!, he discusses the status of the system. I was disappointed to hear that his system wasn’t working, because at first glance it looked very impressive. I decided to learn a little about small hydroelectric systems and document in this notebook what I’ve learned.\n\n\nLake District Overshot Waterwheel Project Review and Analysis\nThis notebook examines the design of a small hydroelectric water wheel built by Kris Harbour Natural Building. The water wheel is a 2.1 meter diameter wheel and he expected to generate between 1.5 and 1.7 kW. The project is documented in four YouTube videos, links are here: Part 1, Part 2, Part 3, Part 4 and Part 5. The videos provide some technical details, but not enough to satisfy me. My JupyterLab notebook will cover the project description, the water wheel design, generator, flume, inverter and other topics he did not address such as instrumentation, safety, maintenance, reliability and economics. (this is a work in progress)\nFuture topics\n\nelectric power, motors, magnetics\n\nInductor and transformer design\n\nElectric propulsion\n\n\n\n\nHeat transfer\n\nHeat sink calculations for audio power amplifier \nCooling of a PCB in a box (example 15-12)\nCooling of a sealed box (example 15-10)\n\n\n\nRadio and RF design\n\nscikit-rf\n\nsignals and spectra, modulation and coding\n\ntopics in microwave engineering\n\nSmith chart plots\n\nantenna design\n\nantenna temperature\n\nreceiver design, analog FE for SDR\n\nLink Analysis\n\nstarlink example (LEO)\n\nDirect to cellphone satellite service\n\n\nHydrogen line receiver\n\nH1 line signal strength\n\nbasic design and feasibility\n\nantenna design, horn, other\n\nreceiver design\n\nfilter design\n\nmapping the sky\n\n\n\n\nInformation security\n\nPassword card\nThis notebook describes the use of a password card and the Python code that generates the password card. The password card is a grid of random letters, numbers and special characters that provides a convenient aid to generate and remember long and complex passwords. A basic description of the password card and instructions are provided along with the Python code used to generate the password card. A security analysis and an analysis of alternatives is provided.\n\nDiceware\n\nEncrypt text for SMS\n\n\n\n\nElectromagnetics\n\ncoil design\n\n\n\nSignal processing\n\nFourier transforms\nDiscrete Fourier transforms\nWindows\nFilters\n\n\n\nCircuit Python\n\nA description is here and here\nA list of hardware supported is here"
  },
  {
    "objectID": "index.html#civil-engineering",
    "href": "index.html#civil-engineering",
    "title": "A collection of Jupyter Notebooks",
    "section": "Civil engineering",
    "text": "Civil engineering\n\nDesign of footings\nCapacity of foudations"
  },
  {
    "objectID": "index.html#mechanical-engineering",
    "href": "index.html#mechanical-engineering",
    "title": "A collection of Jupyter Notebooks",
    "section": "Mechanical engineering",
    "text": "Mechanical engineering\n\nTwo point supported beam\nCantilever beam\nThermal effictiveness of fins\nFluid flow in pipes\nArea moment of inertia\nHelical spring\natmospheric water extraction\ncanaon ball balistics\nTrombe wall\nBoiling eggs (example 4-3)"
  },
  {
    "objectID": "index.html#engineering-economics",
    "href": "index.html#engineering-economics",
    "title": "A collection of Jupyter Notebooks",
    "section": "Engineering economics",
    "text": "Engineering economics\n\nValue analysis\nLinear programming\nCritical path economy\nInterest and money - time relationships\nDepreciation and valuation\nCapital budgeting\nRisk, uncertainty, and sensitivity analysis\nFixed, incremental, and sunk costs\nReplacement studies\nMinimum cost formulas\nVarious economic studies in relation to both public and private ventures"
  },
  {
    "objectID": "index.html#engineering-mathmatics",
    "href": "index.html#engineering-mathmatics",
    "title": "A collection of Jupyter Notebooks",
    "section": "Engineering mathmatics",
    "text": "Engineering mathmatics\n\nDifferential equations\nLinear differential equations\nSimutaneous linear differential equations\nFourier series and integrals\nLaplace transform\nPartial differential equations\nBessel functions\nFunctions of a complex variable\nIntegration in the complex plane\nTheory of reidues\nConformal mapping\nVector analysis\nTaylor series\nGamma and Beta functions\nNumerical soultion of equations"
  },
  {
    "objectID": "Lake District Overshot Waterwheel Project.html",
    "href": "Lake District Overshot Waterwheel Project.html",
    "title": "Lake District Overshot Waterwheel ProjectReview and Analysis",
    "section": "",
    "text": "Note\n\n\n\nLast update: 26 Jan 2024\n\nThis notebook is a draft copy and only half baked.\nSpelling and grammar checks have not been completed.\nThe math still needs a final check.\nThis notebook is posted for testing only.\n\nSome code cells are hidden so as to not distract the reader.\nThe remaining code cells can be viewed by clicking on the &lt;/&gt;Code to the left of the title and selecting show all code.\nIndividual code blocks can be viewed by toggleing the &gt;Code button."
  },
  {
    "objectID": "Lake District Overshot Waterwheel Project.html#scope",
    "href": "Lake District Overshot Waterwheel Project.html#scope",
    "title": "Lake District Overshot Waterwheel ProjectReview and Analysis",
    "section": "1.1 Scope",
    "text": "1.1 Scope\nThe analysis in this notebook will cover the project background as narrated by Kris in the videos. Calculations for the gravitational power of water are presented. A case study of two simular water wheel projects will be reviewed. The hydro system analysis will examine the design parameters. In my analysis, the electrical power generated will be delivered to an resistive load via a three phase, full wave rectifier. Kris was loading the generator with an inverter. I’m not addressing the grid connection. The generator is assumed to have a linear RPM to voltage curve over the water wheel operatating range of rotational rates. A review of the permanent magnet generator and some thermal calculations will be presented. Some discussions about the induction generator will presented, but a detailed analysis of a self excited induction generator will not be presented. Some comments and analysis of the flume are presnted. A few topics not covered in the videos are discussed, such as safety and maintenance. Finally, an economic analysis of the project is presented."
  },
  {
    "objectID": "Lake District Overshot Waterwheel Project.html#review-of-videos",
    "href": "Lake District Overshot Waterwheel Project.html#review-of-videos",
    "title": "Lake District Overshot Waterwheel ProjectReview and Analysis",
    "section": "1.2 Review of videos",
    "text": "1.2 Review of videos\nEach of the videos is about 40 minutes long. While watching, I took notes whenever he gave any technical details. The videos primarily document the build, installationa and some of the testing of the water wheel. The construction of the dam and flume were performed by friends and family. Most of the testing Kris did on site after installation. The exception was some open circuit testing of the first generator in his workshop, which at the time, he thought was adequate.\nPowering An Old Mill - 1.5 Kw Lake District Overshot Waterwheel Project Part 1\n\n2.1m waterwheel, at time 0:16\n\n150 lps max flow rate\n\n50 liter buckets, three per second = 150 lps -&gt; 11.25 rpm\n\ngear reduction 20:1, wheel will do 12 to 16 rpm\n\n500 rpm 2kW, PM alternator\n\nflow 150 liters/sec maximum\n\n50 liter buckets\n\n3 buckets will pass per second\n\n1.5 to 1.7 kW\n\n20:1 gear reduction\n\nbetween 12 and 16 rpm depending on flow rate\n\n500 rpm 2kW PM alternator &lt;- 25 rpm at the waterwheel shaft this seems in conflict\n\nrpm of 16, rotation of 3.7 sec, 230 V from rectifer open circuit\n\n16 buckets\n\n42 L per bucket, measured 45 L\n\nPowering An Old Mill - 1.5 Kw Lake District Overshot Waterwheel Project Part 2\n\nat the site no dam or pond, just the leat\nblocked the water, made some templates and models\nflume = four boards across, walls are set internal and look a bit higher than the individual base boards are wide at time 1:57\nwork on the spill way\nat time 10:16, cutting back the flume\nat time 25:11, connected 3 conductors to bottom of the frame.\nat time 30:22, 340 volts w/o load\nat time 32:03, load test, maybe 1 inch of flow in the flume, buckets are less than half flow making 530 Watts, at time 33:08\nincreased flow, maybe 1 inch in the flume\nat time 34:42, 2nd day of testing, rained overnight and lots of water flowing around the wheel.\nat time 36:37, 2/3rd flow, flume water level looks at the top at the enterence, but just past the gate, the water level is a few inches, reduced to like 1/2 up the side boards, buckets are ??, power 940 Watts\n\nat time 37:22, 3rd day, showing the conduet installed\n\ncomplaning that the controller is letting the wheel spin too fast, but generating 1 kW\nat time 40:16, add some plywood to control the water fill angle, took some slow motion video time-41:38.\n\nat time 42:54, put the controller into constant voltage mode 100V an di splanning to up the voltage based on testing\nwheel spinning much slower, buckets look 1/3 full at time 44:21\nHe thinks the alternator want to spin much faster, it will generate 1000 Watts, but the wheel is spinning too fast, when he uses the controller to slow the wheel for proper bucket filling the power is much less and the alternater got very hot.\n\nPowering An Old Mill - 1.5 Kw Lake District Overshot Waterwheel Project Part 3\n\ngot a bigger pulley, now the total ratio is 20x2=40\ncorner on the flume was improved\n\nKris built a nozzle for the water\nat time 9:21, installed the new pulley and a new lower voltage alternater\nat time 14:11, with flume nozzle buckets look like they are filling better, look about 1/2 full, generater is making 420 Watts\n\nwater flow from the main river down a man made leet,\nat time 16:22, removed the boards that made a temporary dam and much more water is flowing, but the wheel is spinning too fast but making 1160 Watts, earlier 1400 Watts\n2 KW alternater, but only can make 1400 Watts before it gets too hot.\nat time 17:21, 810 Watts when flow rate reduced and wheel spinning at a near proper speed.\nat time 18:33, next day, ran all night, making 750 Watts\nat time 19:19, 600 rpm on the generator (15 rpm on the water wheel), measured with a Tach, generating Alt temp is 80C when generating 750 Watts (that 15 rpm on the wheel shaft)\nat time22:46, 950 Watts is the most it can do before it gets too hot\ntest grid down dump load.\nat time 34:41, took apart the 220 V alternator and the new one is a 96V alternator.\nat time 42:30, new plan is to use an 8 pole induction motor at the generator\n\nWhy did he change to a lower voltage alternater? Old alternater was making 420 volts, he wanted 220 volts.\nPowering An Old Mill 1.5 Kw Lake District Overshot Waterwheel Project Part 4\n\n3 phase induction motor, 8 pole, 750 rpm, 2.2kW (needs a water wheel speed of 18.75 rpm)\n\nmotor face plate: Tec ECHTOP UK CA, Type 2283TECA 83\n\nswitched to a 2kW induction motor, 728rpm, 1711 Watts, 184 volts\n\ntesting of induction motor in John’s hydro electric workshop, drive motor was 3kW, 728rpm, 1711 Watts, 184 volts, 80uF caps\n\nmodifiling the frame and mounting brackets\n\nlooks like a cooling fan on the back of the motor, water side.\n\nadded emergency shut off flap\n\ndump load mounted on wall in poarch, 1.5 kW load\n\nhalf flow test made 860W\n\nfull flow entrance to flume is at the top of the walls, but within everal inches the depth is 1/2, at the end of the flume, depth looks loke 1 inch,\n\nfull flow, water is impacking into the buckets with substantial splash over, generating about 1.6kW, splasing on the generator cover, at the 4 to 5 oclock postion, water sloshing out of the buckets, buckest are 2/3s full, making 1350 Watts\n\nadded plywood to block water exit from the leat in order to increase the flow\n\nflow in the flume looks a bit larger, maybe 2 inches deep at the exit, pitch on the flume looks like a couple of inches, velocity is high, lots of spash over, making 1500 to 1550 Watts, promised the customer 1500 Watts - not a qualified electrician, only doing the mechanicans and making electricity.\nchanging the caps to smaller value\n\nwith some reduced flow, getting 1150 Watts, but less splashing,\n\nat time 22.33, Project Survey from Harbour (2023).\nadded a rpm sensor to run a safety shut off\n\nat time 29:41, with minimal splasing generates about 500 Watts\n\ntesting with gride off, power dumped into load, resistors shown at 50C\n\nPowering An Old Mill 1.5 Kw Lake District Overshot Waterwheel Project Part 5\n\ndesigned an over speed controller\nwater wheel broke and being invesigated, cracked hub on one side, welded back up.\nchanged to dual V-belts from reduction gear box to generator because of allighment issues. Then the wheel was moving slower and after a few days the end plate on the wheel hub cracked.\nV-belt pulley diameters look about the same as the old 2:1\nat time 9:44, RPM sensor set to 18 RPM\nat time 10:50, water wheen running, some water being spashed out of the buckets, substantial amounnt of water in the spillway, Kris says the generator is makeing 1kW.\nKris make a few comment at the end about amount of water flow, but in the video there is lots of water flowing in the spillway, which is at odds with his comment later.\nat time 13:07 Kris showed the cloud data from the inverter, capacity set to 1.6kW, generator makeing 0.78kW (54.3%).Today made 9kWh for a earning of 2.52GBP. Total yeild reported on that day was 479kWh for earning of 134.12 GBP. Dates on the app display show months of Nov and Dec.\nKris claims one of the reasons he’s not too concerned about the excessive splashing is because that flow rate is not representative over most of the year, like mid-winter at the time of recording. But this contradics the stated goal of making 1.5kW and impacts the ROI.\nKris says this is the last video in the seires"
  },
  {
    "objectID": "Lake District Overshot Waterwheel Project.html#units",
    "href": "Lake District Overshot Waterwheel Project.html#units",
    "title": "Lake District Overshot Waterwheel ProjectReview and Analysis",
    "section": "1.3 Units",
    "text": "1.3 Units\nIn the calculations that follow, I’m using the Python package, Pint, which allows mathematical operations with units and conversions to and from different units. Keeping track of the units will provide some error checking when performing the calculations. I’ll be using metric units since this is what Kris has been using. All calculations are done using the International System of units. A list of units and conversions used by Pint is here."
  },
  {
    "objectID": "Lake District Overshot Waterwheel Project.html#variables-and-constants",
    "href": "Lake District Overshot Waterwheel Project.html#variables-and-constants",
    "title": "Lake District Overshot Waterwheel ProjectReview and Analysis",
    "section": "1.4 Variables and constants",
    "text": "1.4 Variables and constants\nThere are a couple of variables and constants that will be used throughout the calculations.\n\nQ is used for flow rate, in this notebook, liters per second\n\ntau or \\(\\tau\\) is used for torque\ng is used to denote the gravity of Earth, standard gravity by definition is equal to 9.80665 \\(m/s^2\\)\nrho or \\(\\rho\\) is used for the density of water, at 50F or 10C is 999.75 \\(kg/m^3\\)\neta or \\(\\eta\\) is used for energy conversion efficiency, accounts for the energy lost to heat"
  },
  {
    "objectID": "Lake District Overshot Waterwheel Project.html#python-package-versions",
    "href": "Lake District Overshot Waterwheel Project.html#python-package-versions",
    "title": "Lake District Overshot Waterwheel ProjectReview and Analysis",
    "section": "1.5 Python package versions",
    "text": "1.5 Python package versions\nThe versions used at the time of writting this notebook are listed in Table 2.\n\n\n\nTable 2: Python package versions\n\n\n\n\n\ntabulate\n0.8.10\n\n\nPython\n3.10.9\n\n\nNumPy\n1.23.5\n\n\nMatplotlib\n3.7.0\n\n\nIPython\n8.10.0\n\n\nPint\n0.22"
  },
  {
    "objectID": "Lake District Overshot Waterwheel Project.html#terminology",
    "href": "Lake District Overshot Waterwheel Project.html#terminology",
    "title": "Lake District Overshot Waterwheel ProjectReview and Analysis",
    "section": "1.6 Terminology",
    "text": "1.6 Terminology\nKris uses the term ‘trough’ for the structure that carries the water to the top of the water wheel; I’ll be using the term Flume to describe the structure.\nOther terms are:\n\nMill race\n\nMill pond\n\nLeat\n\nSluice\n\nWeir\n\nPico hydro\nGrid-tied electrical system"
  },
  {
    "objectID": "Lake District Overshot Waterwheel Project.html#verifying-kriss-estimated-power-versus-flow-rate",
    "href": "Lake District Overshot Waterwheel Project.html#verifying-kriss-estimated-power-versus-flow-rate",
    "title": "Lake District Overshot Waterwheel ProjectReview and Analysis",
    "section": "2.1 Verifying Kris’s estimated power versus flow rate",
    "text": "2.1 Verifying Kris’s estimated power versus flow rate\nIn Harbour (2023), Kris provided his customer an estimated of the power that might be generated versus flow rates. Kris used H = 2.6 meters and \\(\\eta\\) = 0.6. Table 3 shows Kris’s the power versus flow rate.\n\n\n\nTable 3: Kris’s estimated power, head = 2.6 meters, \\(\\eta\\) = 60%\n\n\n\n\n\nFlow rate\nPower, Watts\n\n\n\n\n60 lps\n833\n\n\n70 lps\n1,030\n\n\n80 lps\n1,177\n\n\n90 lps\n1,324\n\n\n100 lps\n1,472\n\n\n110 lps\n1,619\n\n\n116 lps\n1,692\n\n\n\n\n\n\nThe following code plots Kris’s estimated power as red x’s and the power using Wikipedia’s formula as the black solid line. As shown in Figure 2, there is a difference between Kris’s numbers and those obtained using the Wikipedia equation.\n\n\n\n\n\n\n\n\nFigure 2: Kris’s estimated power versus flow rate calculations\n\n\n\n\n\nAt 60 l/s the difference is greater than for the other points. From 70 to 110 l/s, the differece is constant, with a difference of about 3.8%. At 116 l/p, the difference is about 4.6%. I’m not sure why Kris’s numbers differe from the Wikipedia equation. Perhaps he was using different values for H at the various flow rates. Also, it seems courious that the final number in his table is 116 lps and not 120 lps. Additionally, I think he should be using the diameter of the wheel as the head height in his calculations."
  },
  {
    "objectID": "Lake District Overshot Waterwheel Project.html#efficiencies",
    "href": "Lake District Overshot Waterwheel Project.html#efficiencies",
    "title": "Lake District Overshot Waterwheel ProjectReview and Analysis",
    "section": "4.1 Efficiencies",
    "text": "4.1 Efficiencies\nA typical overshot Water wheel has the water channeled to the wheel at the top and slightly beyond the axle. The water collects in the buckets on that side of the wheel, making it heavier than the other “empty” side. The weight turns the wheel and the water flows out into the tail-water when the wheel rotates enough to invert the buckets. The overshot design can achieve 90% efficiency. Nearly all of the energy is gained from the weight of water lowered to the tailrace although a small contribution may be made by the kinetic energy of the water entering the wheel.\nThe efficiencies I’ll be using in my calculations:\n\n\\(\\eta\\) for waterwheel = 90%\n\n\\(\\eta\\) for gear box = 95%\n\n\\(\\eta\\) for generator = 90%\n\\(\\eta\\) for grid-tie inverter = 97%\n\n\n\nThese effencienies have been adjusted to give an overall efficiency in line with what has been acheived in the case studies. The total system efficiency used in the analysis is 74.6%"
  },
  {
    "objectID": "Lake District Overshot Waterwheel Project.html#design-parameters",
    "href": "Lake District Overshot Waterwheel Project.html#design-parameters",
    "title": "Lake District Overshot Waterwheel ProjectReview and Analysis",
    "section": "4.2 Design parameters",
    "text": "4.2 Design parameters\nIn the YouTube video and the project survey, Kris stated that the veritcal height that was available down stream from the dam would allow for a 2.1 meter diameter water wheel with some room clearace above and below. The flume would need to be about 8 meters long. The flow rate avalailbe ranged from 60 to 120 liters per second (lps or l/s) and that the goal was to generate 1,500 Watts, presummably at 120 lps. Most of the technical parameters have been summarized in Table 1. The important paramters for the analysis of the hydro system are the wheel diameter and the water flow rate.\nThe water source for the project is a river that runs adjacent to the property from which a leat diverts a small portion of water to the mill pond. The leat, mill pond as mentioned in the videos were constructed some time ago and the dam had been removed. The range of flow rates from the leat and out of the mill pond was estimated to be in the range of 60 to 116 lps. Kris was hoping to produce 1500 Watts from about 110 lps.\nIn the calculations that follow, I’m using a range of flow rates from 60 to 120 lps and a total efficiency of 75% as discussed above. I’ve decided to include a design margin of \\(\\theta\\) = 15% in the power estimate calculation to account for unknowns and/or poor estimates.\nThe gravitation power of water at various flow rates is plotted in Figure 3. As discussed avove, the head height is 2.1 meters since this is the distance water moves as it is carried by the water wheel’s buckets from the 12 o’clock position to the botton at the 6 o’clock position. The shaded area is the expected nornal variation in flow rate, 60 lps to 120 lps.\n\n\n\n\n\n\n\n\nFigure 3: Estimated power production for a head of 2.1 m at various flow rates\n\n\n\n\n\nThe estimated power production ranges from just below 800 Watts at 60 lps to just almost 1600 Watts at 120 lps. The ability of the hydro system to produce electrical power at these levels is dependednt on a properly designed system operating at the efficiencies discussed above. The included design margin of 15% provides some wiggle room. In Table 3, Kris thought 1500 Watts could be produced with a flow rate between 100 and 110 lps. However, Figure 3, shows that a flow rate of about 115 lps is needed to make 1500 Watts.\n\n\n\nWith a flow rate range of 40 l/s to 180 l/s, the estimated power avaliable is 522.5 W to 2351.3 W, so it appears that making 1300 W at 110 lps and 1500 W at 120 lps is feasable."
  },
  {
    "objectID": "Lake District Overshot Waterwheel Project.html#instrumentation",
    "href": "Lake District Overshot Waterwheel Project.html#instrumentation",
    "title": "Lake District Overshot Waterwheel ProjectReview and Analysis",
    "section": "4.3 Instrumentation",
    "text": "4.3 Instrumentation\nKris utilized only a volt meter and relied on the inverter to provide him an indication of the power being generated. For testing, he should have used a resistive load, a volt meter (which he did use) and an amp meter. He could have used the dump load across the three phase recitfier. This would have eliminated any setup issues with the inverter.\nOther instrumentation which would have been helpful to have for testing and set up of the system:\n\nwater wheel rotation rate\ngenerator frequency\nmill pond surface level\nweb cam on water wheel, mill pond etc. for remote monitoring\ninverter status\n\n\n4.3.1 Inverter\nIn the videos, Kris uses a Solis S6 Series single phase inverter to convert the DC voltage from the rectifier block to AC. He was not clear how the inverter was connected or what the load was during testing. Table 6 provides a summary of the specifications for the 2.5kW inverter.\n\n\n\nTable 6: Specifications for Solis 2.5kW S6 Series\n\n\n\n\n\n\n\n\n\nModel\nS6-GR1P2.5K\n\n\nMax. DC input voltage (Volts)\n550\n\n\nRated DC voltage (Volts)\n250\n\n\nStartup voltage (Volts)\n60\n\n\nMPPT voltage range (Volts)\n50 to 450\n\n\nMax. input current (Amps)\n14+14\n\n\nRated output power (Watts)\n2500\n\n\nRated grid voltage (Volts)\n1/N/PE, 220/230\n\n\nRated output current (Amps)\n11.4/10.9\n\n\nMax. output current (Amps)\n13.3\n\n\nPower Factor (at rated output power)\n&gt; 0.99 (0.8 leading - 0.8 lagging)\n\n\nTHDi (at rated output power)\n&lt;3%\n\n\nRated grid frequency (Hertz)\n50/60\n\n\nOperating frequency range (Hertz)\n45 to 55 or 55 to 65\n\n\nMax.efficiency\n97.3%\n\n\nEU efficiency\n96.5%\n\n\n\n\n\n\nKris was able to control the speed of the wheel by changing the mode to constant voltage mode and setting the value to 100 volts. This casued the generator to get smoking hot under full flow conditions. About this time he started to suspect that the rating of the generator was much less than indicated on the face plate of the generator. But the situation is a little confusing. I suspect that the availavle power was much greater than the power indicated on the inverter display, so the difference was being dissipated as heat in the generator, since the generator was being forced to provide a breaking load to the water wheel. This is why using a fixed power resistor as the load would have been much better for inital testing.\nThere are a couple things to keep in mind.\n\nThe maximum DC input voltage is 550 Volts, so some determination would need to be made if a free spinning water wheel could under any conditions, normal or abnoramal, cause the generator to produce a voltage in excess of this limit. If there is a chance, then some sort of over voltage protection is needed. Earily in the video series, Kris did check the open circuit voltage out of the rectifier and a high flow rate an measured 350 Volts, but this was hardly a comprhensive analysis of the maximum possible voltage.\nThe operating mode of the Solis S6 Series needs to be investigated, because it’s not clear to me that a MMP mode is optimum for a small hydro system running open loop.\n\n\n\n4.3.2 Electrical load for analysis and testing\nIn the videos, Kris was using inverter as the electrical load for the generator. I think he should have been using a high power resistive load for his inital tests. Three portable electric heaters or his dump load could have been used for testing. Once everything was sorted out, he could then connect to the Solis S6 Series inverter for additional tests.\nTo calculate the load resistance for my analysis, I’m assuming that 1500 Watts is the load he should be using; I’m assuming the geneator makes 220 volts line to line, at the rated power, at 500 RPM.\nThe generator is connected to rectifier block. Kris didn’t say too much about the rectifier, so I’ll assume that it is a three phase full wave rectifier with six diodes being used to convert the three phase alternating current to direct current.\nThe voltage across the positive and negative terminals of the recitfier block is calculated from the generator output line to line voltage by the following:\n\\(V_{load(DC)} = \\frac{3\\sqrt{2}}{\\pi} V_{generator L-L(RMS)}\\)\nThis equation is described in the Wikipedia article, Three-phase bridge rectifier uncontrolled. The Wikipedia derivation uses line to netural, whereas I’m using line to line, so that’s why my equation is a written differently than in the article.\n\n\nRearranging the relation: \\(P=V^2/R\\), we can calculate the value of the resistor needed to dissapate 1500 Watts at voltage developed by 500 RPM on the generator shaft. A load resistance of 58.8 Ω will provide the required load"
  },
  {
    "objectID": "Lake District Overshot Waterwheel Project.html#gear-box",
    "href": "Lake District Overshot Waterwheel Project.html#gear-box",
    "title": "Lake District Overshot Waterwheel ProjectReview and Analysis",
    "section": "4.4 Gear box",
    "text": "4.4 Gear box\nA gear box is required to convert the relatively low rotational speed of the water wheel to a higher rotational speed required for the generator. Kris is using a combination of a reduction box driven from the low end to step up the RPM by 20. Later he added a larger pulley to provide an addition step up in RPM of 2; this is a total RPM step up of 40."
  },
  {
    "objectID": "Lake District Overshot Waterwheel Project.html#generator-and-rectifier-voltage",
    "href": "Lake District Overshot Waterwheel Project.html#generator-and-rectifier-voltage",
    "title": "Lake District Overshot Waterwheel ProjectReview and Analysis",
    "section": "4.5 Generator and rectifier voltage",
    "text": "4.5 Generator and rectifier voltage\nI’m going to assum that the generator’s output voltage is linear with respect to the generator shaft rotational speed (at least over the expected operating RPM range, some where near the water wheel rotational speed of 10 RPM). In the videos, Kris used several generators and he usually measured the generator voltage at the output recifier. The first generator appears to have a rated voltage of 220 Volts line to line. Later this generator was swapped out for one with a lower voltage rating of 96 Volts. In the final video, Kris changes the generator to a self excied induction generator.\nFrom my recolection, Kris allways measures the voltage at the recitfier’s DC terminals.\nIn the first video Kris measured 230 Volts out of the recitfier when he was spining the wheel in his shop at what estimated was the proper speed. I’m wondering if he was spinning to get 230 volts and calling that the proper speed? In the second video he measured 240 volts when the wheel was free spinning.\n\nKris didn’t explain why he changed from 220 to 96 volts except to say he was concerned that the wheel was spinning too fast.\nThe initial design had the 220 Volt generator, so that’s what I’m going with for the initial part of the analysis, later I’ll address the generator questions.\n\nThe plot below shows the line to line generator voltage vs water wheel RPM, assuming a gear box of 40:1. The genertor needs 500 shaft RPM to make 220 volts at the rated power. One of the issues with Kris’s design is the gear ratio is too low. I think the ratio needs to be more like 1:60 to keep the water wheel RPM in the optimal range.\n\n\n\n\n\n\n\n\nFigure 4: generator output voltage vs water wheel RPM\n\n\n\n\n\nA water wheel rotational speed of 6 to 12 RPM is expected to be the optium range of the wheel rotation, which is highlighted in the plot above. The optimum range is based on the expected seasonal flow rates ranging from 60 lps to 120 lps and the tangential velocity of the wheel matching the water velocity in the flume. As describe above, the hydro system’s flow rate is not regulated, so there will be a range of flows that the water wheel is expected to encounter.\nAs shown in Figure 4, the line to line output of the generator is a function of the water wheel rotational speed. For this analysis we are assuming that the relationship is linear over this range. For a permanent magnet generator, this is usally the case, and typically a generator’s performance curve will show a high degree of linearity over the middile part of the RPM range. Later in the project Kris changed generators, as described below, to an induction generator running in a self excited configuration. An induction generator, while being a valid and reasonable option, requires a different set of assumtpings for the analysis, since self excited induction generators have poor voltage regulation. Which means that after the induction generator’s voltage climes to a voltage near the operating voltage during startup and the ‘system’ applies a load, the voltage will drop by a significant amount.\n\nLater, I’ll look at power flow through the hydo system. Power from gravity on the mass of the water, to the rotational power of the wheel (RPM x torque), to the genrator and finally to the electrical test load. Accounting for losses along the way, the power delivered to the electrical load should be equal to the rotational power of the wheel minus the losses."
  },
  {
    "objectID": "Lake District Overshot Waterwheel Project.html#water-wheel",
    "href": "Lake District Overshot Waterwheel Project.html#water-wheel",
    "title": "Lake District Overshot Waterwheel ProjectReview and Analysis",
    "section": "4.6 Water wheel",
    "text": "4.6 Water wheel\nThe water wheel the Kris designed and fabricated has a diameter of 2.1 meters, 16 buckets, each with a capacity of 48 liters and the wheel width is 0.8 meters. In the calculations that follow, I’m assuming the wheel will have a rotational frequency of between 5 to 15 rotations per minute (rpm). The electrical load on the generator will limit the rotational frequency of the water wheel by resisting the torque delivered to the generator shaft. The electrical load is provided by the inverter. Through out the calculations that follow, I’m assuming that the wheel rotation frequency will be limited by the electrical load placed on the generator by the inverter. If the wheel is making 1000 Watts and delivering this power to the generator shaft, it is assumed that the generator will extract the power at an RPM within the range of 5 to 15 RPM based on the power delivered to the electrical load.\nThere are 16 buckets, each with a capacity of 48 liters. I’ll assum that the buckets will fill to a level of 95% of the bucket volumn. However, Kris stated in his video, that he though the bucket capacity was more like 50 liters because of the side wall of the wheel frame. In all the water wheels that I have observed on various YouTube videos, the buckets don’t fill to 100%. I’ll assume that the buckets are being filled to 95% of capacity.\n\n\n4.6.1 Water carring capacity vs rpm\nFor a give rpm and fill level, the water wheel can move a fixed amount of water. The water carring capacity is calculated by taking the rotation frequency times the number if buckets times the bucket capacity utilization. The Python pint library keeps track of the units. The number of buckets has the dimention of 16 per circle, so the product of the terms has dimentions that can be converted to liters per second.\nThe water wheel carring capacity at various flow rates is plotted below.\n\n\n\n\n\n\nNote\n\n\n\nI’m not sugesting that the water wheel can actually carry the volumn of water at RPM’s above 12 or so. The efficient filling of buckets probably requires that the tangential velocity of the water wheel approximately matches the water velocity at the flume exit.\n\n\n\n\nCode\nplt.plot(water_wheel_rotation_frequency.magnitude,\n    (water_wheel_rotation_frequency*sys_param['number of buckets']*sys_param['bucket volume']*sys_param['bucket utilization']).to('liter/sec').magnitude, '-')\n\n# hightlight the operating band, 8 to 14 RPM\nplt.axvspan(6, 12, color='y', alpha=0.3)\n\nplt.xlim((4,15))\n#plt.ylim((40,200))\nplt.grid()\n\nplt.ylabel('water carring capacity, l/s')\nplt.xlabel('wheel RPM')\n\nplt.title('water carring capacity, buckets are {:.0f}% full'.format(sys_param['bucket utilization']*100))\nplt.show()\n\n\n\n\n\n\n\n\nFigure 5: water carring capacity vs water wheel RPM\n\n\n\n\n\n\nAt 10 RPM, the wheel can move at most 121 lps. At higher flow rates, the excess water will overflow the buckets and not contribute any additional weight to the bucket and consequently torque to the wheel. I did notice that the water velocity in the flume was too high and buckets were not filling efficiently except at very low flow rates."
  },
  {
    "objectID": "Lake District Overshot Waterwheel Project.html#power-equilibrium",
    "href": "Lake District Overshot Waterwheel Project.html#power-equilibrium",
    "title": "Lake District Overshot Waterwheel ProjectReview and Analysis",
    "section": "4.7 Power equilibrium",
    "text": "4.7 Power equilibrium\nThe calculations that follow will estimate the equilibrium point between the power produced by the water wheel and the power consumed by the electrical load. The assumption is that the buckets are being filled efficiently. However, we know that if the water velocity is too high the buckets will not fully fill since a lot of the water will splash out of the buckets. The water velocity entering the buckets needs to be about the same as the tangential wheel velocity.\n\n4.7.1 Water wheel torque vs rpm\nThe force that turns the wheel is provided by gravity and the mass of the water. Only about half of the buchets on one side of the wheel are filled with water and the weight imbalance causes the wheel to turn under the force of gravity. The turning force us called torque and is a measure of the force that produces a rotation. To calculate the torque, we use the horizontal distance of each bucket with water from the axis of the wheel multiplied by the force of gravity acting on the mass of the water. The units of torque are Newton meters.\nThe moment arm for each bucket on one side of the wheel is calculated by taking the sin of angle for each buckets position and mutiplying by the radius of the wheel. We want to do a series of calculations for a set of flow rates and water wheel rotational speeds. Each bucket can only carry 47 liters, so if the flow rate is too high for the rotational speed, the butckets will over flow and only the weight of the actual water in the bucket is counted.\nThe calculations below assume that the water is filling the buckets in an efficicent manner and the momentum of the water is not included in the torque calculatons. If the water did have a lot of momentum, it would splash out of the buckets rather than filling them, which is what we see in the videos.\n\n\nCode\n# calculate the horizontal distance for each bucket on one side\nx = np.linspace(0, np.pi,int(sys_param['number of buckets'].magnitude/2))\nmoment_arm = (sys_param['wheel diameter']/2)*np.sin(x)\n\n# do the calculations from 5 to 20 rpm using 100 points\nwater_wheel_rotation_frequency = (np.linspace(5,20,100))*ureg.rpm\n\nfor i in range(len(Q)):  # use the same flow rate range from above\n    water_wheel_shaft_torque = np.zeros(len(water_wheel_rotation_frequency))*ureg.kilogram*ureg.g0*ureg.meter # creat an empty array with the proper units attached\n\n    for j in range(len(water_wheel_rotation_frequency)):\n        # given the rotational rate, how much water can be moved, if the buckets were full?\n        water_transport_rate = (sys_param['number of buckets']*sys_param['bucket volume']*water_wheel_rotation_frequency[j]).to('liter/sec')\n\n        bucket_utilization = Q[i]/water_transport_rate # estimate of how full the buckets are\n        \n        # limit transport rate to flow rate\n        if bucket_utilization &gt; 1:\n            bucket_utilization = 1\n            water_transport_rate = Q[i]\n\n        weight_of_water_per_bucket = (rho*sys_param['bucket volume'])*bucket_utilization\n\n        torque_per_bucket = (weight_of_water_per_bucket*ureg.g0*moment_arm).to_base_units()\n        water_wheel_shaft_torque[j] = torque_per_bucket.sum()    \n     \n    plt.plot(water_wheel_rotation_frequency.magnitude,water_wheel_shaft_torque.to('N m').magnitude,'-',label='{:.1f~P}'.format(Q[i]))\n\nplt.grid()\n\n# hightlight the operating band, 8 to 14 RPM\nplt.axvspan(6, 12, color='y', alpha=0.3)\n\nplt.ylabel('water wheel shaft torque, N m')\nplt.xlabel('wheel rpm')\n\nplt.title('Water wheel shaft torque vs RPM at various flow rates')\nplt.legend(loc=1)\n\nplt.show()\n\n\n\n\n\n\n\n\nFigure 6: Water wheel shaft torque vs RPM at various flow rates\n\n\n\n\n\nThe plot above shows the water wheel shaft torque over a range of wheel RPM and flow rates. At the lowest flow rate plotted, 40 lps, the buckets do not completely fill at any of the wheel RPMs plotted. The 60 lps torque curve decreases with increasing RPM because at higher rotational speeds, there is less water in each bucket, which contributes less force to the moment arm. At the next flow rate plotted, 80 lps, you can see that at a wheel RPM of just under 6, the buckets are completely full and the torque is constant at about 2164 Nm. At the highest flow rate plotted, 180 lps, if the wheel is spinning faster than 14 RPM, the buckets are only partially filled with water and the torque decreases with wheel RPM. This analysis assumes that the buckets can efficiently fill with water over the range of rotational speeds; but above 12 RPM this is doubtful since there will likely be a mismatch between the water velocity in the flume and the tangential velocity of the wheel.\n\n\n4.7.2 Water wheel shaft power vs rpm\nHaving calculated the water wheel shaft torque over a range of wheel RPMs and flow rates, we can use the same method to calculate the water wheel shaft power, which is the product of torque, rotational speed and water wheel efficiency.\n\n\nCode\nfor i in range(len(Q)):\n    water_wheel_shaft_torque = np.zeros(len(water_wheel_rotation_frequency))*ureg.kilogram*ureg.g0*ureg.meter\n\n    for j in range(len(water_wheel_rotation_frequency)):\n        water_transport_rate = (sys_param['number of buckets']*sys_param['bucket volume']*water_wheel_rotation_frequency[j]).to('liter/sec')\n\n        bucket_utilization = Q[i]/water_transport_rate\n\n        # limit transport rate to flow rate\n        if bucket_utilization &gt; 1:\n            bucket_utilization = 1\n            water_transport_rate = Q[i]\n\n        weight_of_water_per_bucket = (rho*sys_param['bucket volume'])*bucket_utilization\n\n        torque_per_bucket = (weight_of_water_per_bucket*ureg.g0*moment_arm).to_base_units()\n        water_wheel_shaft_torque[j] = torque_per_bucket.sum()    \n\n    plt.plot(water_wheel_rotation_frequency.magnitude,(water_wheel_shaft_torque*water_wheel_rotation_frequency*eta_waterwheel).to('watts').magnitude,'-',label='{:.1f~P}'.format(Q[i]))\n\nplt.grid()\n\n# hightlight the operating band, 8 to 14 RPM\nplt.axvspan(6, 12, color='y', alpha=0.3)\n\nplt.ylabel('water wheel shaft power, Watts')\nplt.xlabel('wheel rpm')\n\nplt.title('Water wheel shaft power vs RPM at various flow rates')\nplt.legend(loc=0)\n\nplt.show()\n\n\n\n\n\n\n\n\nFigure 7: Water wheel shaft power vs RPM at various flow rates\n\n\n\n\n\nThe plot above shows that the water wheel shaft power is constant for a flow rate of 60 lps. A faster spinning wheel will have less torque since the buckets are less full and less weight in the buckets produces less torque, but since power is the product of torque and rotational speed, the result is constant over the range of RPMs. At the highest flow rate of 180 lps, the shaft power increases with wheel RPM since up to about 14 RPM where the buckets are completely full.\nThe shape of the power curve versus wheel RPM indicates that a Maximum Power Point Tracking (MPPT) algorithm will hunt for a peak in the curve, probably by letting the RPM increase, where at some point the buckets will not fill efficiently and there will be a decrease in torque. This would suggest that MPPT is not ideal.\nPower equilibrium at 100 lps\nThe calculations below, tabulate the water wheel shaft torque and water wheel shaft power at a flow rate of 100 lps over a range of RPMs. The water wheel shaft power is labeled here as available power. Available power is the power the water wheel could deliver if it was allowed to rotate at the particular RPM indicated in each row of the table. For each water wheel RPM, the generator line to line voltage is calculated using a straight line approximation based on the ratio of 220 volts to 500 RPM and the DC voltage, current and electrical power on the load is calculated.\n\n\nCode\nwater_wheel_rotation_frequency = (np.arange(5,21))*ureg.rpm\n\ni = 3 # index of 3 is 120 lps\n\ntable_header = ['flow','rpm','torque','avaliable pwr','load volts','load amps','load pwr']\ntable_row = []\n\nwater_wheel_shaft_torque = np.zeros(len(water_wheel_rotation_frequency))*ureg.kilogram*ureg.g0*ureg.meter\n\nfor j in range(len(water_wheel_rotation_frequency)):\n    water_transport_rate = (sys_param['number of buckets']*sys_param['bucket volume']*water_wheel_rotation_frequency[j]).to('liter/sec')\n\n    bucket_utilization = Q[i]/water_transport_rate\n\n    # limit transport rate to flow rate\n    if bucket_utilization &gt; 1:\n        bucket_utilization = 1\n        water_transport_rate = Q[i]\n\n    weight_of_water_per_bucket = (rho*sys_param['bucket volume'])*bucket_utilization\n\n    torque_per_bucket = (weight_of_water_per_bucket*ureg.g0*moment_arm).to_base_units()\n    water_wheel_shaft_torque[j] = torque_per_bucket.sum()    \n\n    # calculate the avaliable power produced by the water wheel\n    available_pwr = (water_wheel_shaft_torque[j]*water_wheel_rotation_frequency[j]*eta_waterwheel)\n\n    # calculate the generator output voltage at each rotational speed\n    V_line_line_rms = sys_param['volts to RPM']*water_wheel_rotation_frequency[j].magnitude*sys_param['gear ratio']*ureg.volt\n    \n    #Vp_rms = V_line_line_rms/np.sqrt(3)\n    #Vp_peak = Vp_rms*np.sqrt(2)\n    #V_load = (3*np.sqrt(6)/np.pi)*Vp_rms\n    V_load = V_line_line_rms*3*np.sqrt(2)/np.pi\n   \n    load_current = V_load/R_load\n    load_pwr = (R_load*load_current**2)*eta_gear_box*eta_generator    \n    \n    #load_volts = (220/500)*water_wheel_rotation_frequency[j].magnitude*gear_box*ureg.volt\n    #load_current = load_volts/R_load\n    #load_pwr = R_load*load_current**2\n    \n    table_row.append(\n            [Q[i].magnitude,\n            water_wheel_rotation_frequency[j].magnitude,\n            water_wheel_shaft_torque[j].to('N m').magnitude,\n            available_pwr.to('watts').magnitude,\n            V_load.magnitude,\n            load_current.magnitude,\n            load_pwr.magnitude])                                                                   \n    \nMarkdown(tabulate(table_row, headers=table_header,colalign = ('left','decimal','decimal','decimal','decimal','decimal','decimal'),tablefmt=\"simple\",floatfmt=('.0f','.0f',',.1f',',.1f','.1f','.1f',',.1f')))\n\n\n\n\nTable 7: Power equilibrium\n\n\n\n\n\n\nflow\nrpm\ntorque\navaliable pwr\nload volts\nload amps\nload pwr\n\n\n\n\n100\n5\n2,164.9\n1,020.2\n118.8\n2.0\n205.2\n\n\n100\n6\n2,164.9\n1,224.2\n142.6\n2.4\n295.5\n\n\n100\n7\n2,164.9\n1,428.3\n166.4\n2.8\n402.2\n\n\n100\n8\n2,114.2\n1,594.1\n190.1\n3.2\n525.3\n\n\n100\n9\n1,879.3\n1,594.1\n213.9\n3.6\n664.8\n\n\n100\n10\n1,691.4\n1,594.1\n237.7\n4.0\n820.8\n\n\n100\n11\n1,537.6\n1,594.1\n261.5\n4.4\n993.2\n\n\n100\n12\n1,409.5\n1,594.1\n285.2\n4.8\n1,182.0\n\n\n100\n13\n1,301.0\n1,594.1\n309.0\n5.3\n1,387.2\n\n\n100\n14\n1,208.1\n1,594.1\n332.8\n5.7\n1,608.8\n\n\n100\n15\n1,127.6\n1,594.1\n356.5\n6.1\n1,846.8\n\n\n100\n16\n1,057.1\n1,594.1\n380.3\n6.5\n2,101.2\n\n\n100\n17\n994.9\n1,594.1\n404.1\n6.9\n2,372.1\n\n\n100\n18\n939.6\n1,594.1\n427.8\n7.3\n2,659.4\n\n\n100\n19\n890.2\n1,594.1\n451.6\n7.7\n2,963.1\n\n\n100\n20\n845.7\n1,594.1\n475.4\n8.1\n3,283.2\n\n\n\n\n\n\n\n\n\nThe available power and the load power will reach equilibrium at around 14 RPM. The point of intercestion is plotted below.\n\n\nCode\nwater_wheel_rotation_frequency = (np.linspace(5,20,100))*ureg.rpm\n\n# initialize some empty arrays\nwater_wheel_shaft_torque = np.zeros(len(water_wheel_rotation_frequency))*ureg.kilogram*ureg.g0*ureg.meter\navailable_pwr = np.zeros(len(water_wheel_rotation_frequency))*ureg.watt\nload_pwr = np.zeros(len(water_wheel_rotation_frequency))*ureg.watt\n\nfor j in range(len(water_wheel_rotation_frequency)):\n    water_transport_rate = (sys_param['number of buckets']*sys_param['bucket volume']*water_wheel_rotation_frequency[j]).to('liter/sec')\n\n    bucket_utilization = Q[i]/water_transport_rate\n\n    # limit transport rate to flow rate\n    if bucket_utilization &gt; 1:\n        bucket_capacity_utilization = 1\n        water_transport_rate = Q[i]\n\n    weight_of_water_per_bucket = (rho*sys_param['bucket volume'])*bucket_utilization\n\n    torque_per_bucket = (weight_of_water_per_bucket*ureg.g0*moment_arm).to_base_units()\n    water_wheel_shaft_torque[j] = torque_per_bucket.sum()    \n\n    # calculate the generator out put voltage at each rotational speed\n    available_pwr[j] = (water_wheel_shaft_torque[j]*water_wheel_rotation_frequency[j]*eta_waterwheel)\n    V_line_line_rms = sys_param['volts to RPM']*water_wheel_rotation_frequency[j].magnitude*sys_param['gear ratio']*ureg.volt\n    \n    #Vp_rms = V_line_line_rms/np.sqrt(3)\n    #Vp_peak = Vp_rms*np.sqrt(2)\n    #V_load = (3*np.sqrt(6)/np.pi)*Vp_rms\n    V_load = V_line_line_rms*3*np.sqrt(2)/np.pi\n   \n    load_current = V_load/R_load\n    load_pwr[j] = (R_load*load_current**2)*eta_gear_box*eta_generator  \n    \nplt.plot(water_wheel_rotation_frequency.magnitude, available_pwr.to('watts').magnitude,'-',label='available pwr')\nplt.plot(water_wheel_rotation_frequency.magnitude, load_pwr.to('watts').magnitude,'-',label='load pwr')  \n\nidx = np.argwhere(np.diff(np.sign(load_pwr.to('watts').magnitude - available_pwr.to('watts').magnitude))).flatten()\nplt.plot(water_wheel_rotation_frequency.magnitude[idx], load_pwr.to('watts').magnitude[idx], 'ro')\nplt.plot(water_wheel_rotation_frequency.magnitude[idx], available_pwr.to('watts').magnitude[idx], 'kx')\n\n# hightlight the operating band, 6 to 12 RPM\nplt.axvspan(6, 12, color='y', alpha=0.3)\n\nplt.grid()\n\nplt.ylabel('power, Watts')\nplt.xlabel('wheel rpm')\n\nplt.title('available power from water wheel, power to R_load = {:.1f~P} @ flow = {:.1f~P}'.format(R_load,Q[i]))\nplt.legend(loc=0)\n\nplt.show()\n\n\n\n\n\n\n\n\nFigure 8: Power equilibrium\n\n\n\n\n\n\n\n\nCode\n#print('the curves intersect at {:.1f} rpm and {:.1f} W'.format(float(water_wheel_rotation_frequency.magnitude[idx]),float(load_pwr.to('watts').magnitude[idx])))\nMarkdown('The plot above shows that equilibrium will be reached when the available power from the water wheel matches the electrical \\\npower delivered to the load resistor at {:.1f} RPM and {:.1f} Watts.'.format(float(water_wheel_rotation_frequency.magnitude[idx]), float(load_pwr.to('watts').magnitude[idx])))\n\n\nThe plot above shows that equilibrium will be reached when the available power from the water wheel matches the electrical power delivered to the load resistor at 13.8 RPM and 1560.4 Watts.\n\n\nBy calculating the equilibrium point, we can estimate the rotational speed of the water wheel under load. As discussed below, 15 RPM is too fast for the efficient filling of the buckets. This indicates that the gearbox ratio need to be higher. By adjusting the gearbox ratio and re-running the calculations above, a gearbox ratio of 50 will produce equilibrium at about 10 RPM.\nPower equilibrium vs flow rate\n\\(\\large{\\color {red} {\\text{why is the blue line flat? should it not ahve a knee below 8 RPM?}}}\\)\n\n\nCode\nMarkdown('The power equilibrium points for a gear ratio of 1:{:d} are tabulated below.'.format(sys_param['gear ratio']))\n\n\nThe power equilibrium points for a gear ratio of 1:40 are tabulated below.\n\n\n\n\nCode\nwater_wheel_rotation_frequency = (np.linspace(5,20,100))*ureg.rpm\ntable_header = ['flow, lps','wheel rotation, RPM','load pwr, W']\ntable_row = []\n\nfor i in range(len(Q)):\n\n    water_wheel_shaft_torque = np.zeros(len(water_wheel_rotation_frequency))*ureg.kilogram*ureg.g0*ureg.meter\n    available_pwr = np.zeros(len(water_wheel_rotation_frequency))*ureg.watt\n    load_pwr = np.zeros(len(water_wheel_rotation_frequency))*ureg.watt\n\n    for j in range(len(water_wheel_rotation_frequency)):\n        water_transport_rate = (sys_param['number of buckets']*sys_param['bucket volume']*water_wheel_rotation_frequency[j]).to('liter/sec')\n\n        bucket_utilization = Q[i]/water_transport_rate\n\n        # limit transport rate to flow rate\n        if bucket_utilization &gt; 1:\n            bucket_utilization = 1\n            water_transport_rate = Q[i]\n\n        weight_of_water_per_bucket = (rho*sys_param['bucket volume'])*bucket_utilization\n\n        torque_per_bucket = (weight_of_water_per_bucket*ureg.g0*moment_arm).to_base_units()\n        water_wheel_shaft_torque[j] = torque_per_bucket.sum()    \n\n        # calculate the generator out put voltage at each rotational speed\n        available_pwr[j] = (water_wheel_shaft_torque[j]*water_wheel_rotation_frequency[j]*eta_waterwheel)\n        V_line_line_rms = sys_param['volts to RPM']*water_wheel_rotation_frequency[j].magnitude*sys_param['gear ratio']*ureg.volt\n\n        #Vp_rms = V_line_line_rms/np.sqrt(3)\n        #Vp_peak = Vp_rms*np.sqrt(2)\n        #V_load = (3*np.sqrt(6)/np.pi)*Vp_rms\n        V_load = V_line_line_rms*3*np.sqrt(2)/np.pi\n\n        load_current = V_load/R_load\n        load_pwr[j] = (R_load*load_current**2)*eta_gear_box*eta_generator\n\n    idx = np.argwhere(np.diff(np.sign(load_pwr.to('watts').magnitude - available_pwr.to('watts').magnitude))).flatten()\n    table_row.append([Q[i].magnitude,water_wheel_rotation_frequency.magnitude[idx],load_pwr.to('watts').magnitude[idx]])\n                                                                       \nMarkdown(tabulate(table_row, headers=table_header,colalign = ('left','left','left'),tablefmt=\"simple\",floatfmt=('.0f',',.2f','.1f'))) \n\n\n\n\nTable 8: Power equilibrium intersection points at various flow rates\n\n\n\n\n\n\nflow, lps\nwheel rotation, RPM\nload pwr, W\n\n\n\n\n40\n8.79\n633.9\n\n\n60\n10.76\n949.9\n\n\n80\n12.42\n1267.0\n\n\n100\n13.79\n1560.4\n\n\n120\n15.15\n1884.3\n\n\n140\n16.36\n2197.8\n\n\n160\n17.58\n2535.5\n\n\n180\n18.64\n2850.8\n\n\n\n\n\n\n\n\n\nWith a gear ratio of 1:40, the hydro system will not make 1500 Watts at a reasonable water wheel RPM.\n\n\n4.7.3 Wheel tangential velocity vs RPM\nThe water wheel tangential velocity versus RPM is plotted below. Water wheel rotational frequency, given the units of RPM, is being used to demote rotational speed or rotatinal rate. The units used in the calculations need to include the number \\(2\\pi\\) in the calculations because angular rate in radians is used in the calculations. Converting rtoatinal frequency to Hz takes care of the conversion.\n\n\nCode\nwater_wheel_rotation_frequency = (np.arange(5,16))*ureg.rpm\n\nplt.plot(water_wheel_rotation_frequency.magnitude,(sys_param['wheel diameter']/2*water_wheel_rotation_frequency.to('Hz')).to_base_units().magnitude,'-')\n\n# hightlight the operating band, 8 to 14 RPM\nplt.axvspan(6, 12, color='y', alpha=0.3)\n\nplt.grid()\n\nplt.ylabel('Wheel tangential velocity, m/s')\nplt.xlabel('wheel RPM')\n\nplt.title('Wheel tangential velocity')\nplt.show()\n\n\n\n\n\n\n\n\nFigure 9: Wheel tangential velocity\n\n\n\n\n\n\nFlume water velocity should match the tangential velocity at the flow rate."
  },
  {
    "objectID": "Lake District Overshot Waterwheel Project.html#generator",
    "href": "Lake District Overshot Waterwheel Project.html#generator",
    "title": "Lake District Overshot Waterwheel ProjectReview and Analysis",
    "section": "4.8 Generator",
    "text": "4.8 Generator\nThere were two types of generators used in the project. The initial type was a Perminate Magnet Generator (PMG). The second type was an induction generator. In part 1 of the video series, Kris indicated that PMG was a 2kW, 220 Volt generator. Later in part 2, the 220V PMG wass changed to a 96V PMG of the same type.\n\n4.8.1 2kW 3 phase PMG, 220V/96V types\nFirst generator is a 2kW PM generator, exact specifications are not clear. Different voltages were used. Kris was unhappy about the perforance of the 1st generator.\nThe PMG is a Rewindagic generator obtained from from AliExpress, which was as far as I can tell is a 2kW, low speed permanent magnet generator, available in various voltages such as 48V, 220V, 400V. See Table 9\n\n\n\nTable 9: Rewindagic generator specifications\n\n\n\n\n\nModel: PMG-2000L\n\n\n\n\n\nRated power\n2000W\n\n\nMax power\n2500W\n\n\nRated voltage\n220v\n\n\nRated rotated speed\n500 RPM\n\n\nStart torque\n0.74 Nm\n\n\nRated torque\n16.4 Nm\n\n\nWorking temperature\n-40 to 80 C\n\n\n\n\n\n\nKris should have test this generator on a test stand, then mocked up the generator with the gear box and pulleys. I don’t know what he was expecting the water wheel rotational speed to be when he was doing the design, but 10 RPM at 120 lps seems about right to me. He needed a gear ratio of 10:500 or 1:50, but his inital design was a 1:20. Later he upped the gear ratio to 1:40.\nKris complained complained about the PMG overheating and could only make 1500 Watts for less than a minute before getting smoking hot. He also had difficulty getting the inverter and PMG to regulate the rotational speed of the water wheel, which may have promted him to change from 220 to 96 Volts. In part 3, Kris open the PMG case and measured the diamter of the wire in the windings and found it to be 0.7mm. There was some correspondence with the generator supplier and Kris concluded that the generator was improperly characterized and probably more like a 500 Watt generator rather than a 2kW generator.\nTesting on a gernerator test stand, rather than on site infront of the customer, is always prefered. He would have determine if the Rewindagic generator would meet his needs. He designed the gear box and PMG mounting around an untested generator.\n\n4.8.1.1 Thermal calculations\nThe following are some calculations to estimate the heat flow out of the PMG. The available power that can be delivered from the water wheel to the shaft of the generator at 120 lps is calculated below.\n\n\nCode\nH = 2.1*ureg.meter # head equal to the wheel diameter\nQ = 120*ureg.liter/(1*ureg.sec)\navailable_power_to_generator = (rho*g*Q*H*eta_waterwheel*eta_gear_box).to('watt')\n#print('available power to generator: {:,.1f~P}'.format(available_power_to_generator))\nMarkdown('The available power to generator is {:,.1f~P}'.format(available_power_to_generator))\n\n\nThe available power to generator is 2,112.4 W\n\n\nAssuming that the generator will convert avaliable power to electrical energy, then losses internal to the generator will produce heat.\n\n\nCode\n#print('generator losses as heat: {:.1f~P}'.format((available_power_to_generator*(1-eta_generator)).to('watt')))\nMarkdown('The generator losses as heat based on efficiency are {:.1f~P}'.format((available_power_to_generator*(1-eta_generator)).to('watt')))\n\n\nThe generator losses as heat based on efficiency are 211.2 W\n\n\nThere are three paths for the internal heat to exit the PMG body, by convection, radiation and conduction. The heat flow from from each of these paths is estimated based on using a maximum ambient temperature of 38C and a maximum allowed generator case temperature of 80C.\n\n\n4.8.1.2 Convected heat\nThe heat convected from the PMG can be estimated by modeling the generator body as a horizontal cylinder with hemispheric end pieces. A simplified relation for natural convection heat transfer coefficient for a horizontal cylinder, was used from Çengel (2003), Table 15-1. Also see example 15-10, page 816.\nThe formula for the heat transfer coefficient for a horizontal cylinder is:\n\\(h_{conv}=1.32 {\\frac {\\Delta T}{D}}^{0.25}\\)\nwhere:\n\\(h_{conv}\\) = heat transfer coefficient for a horizontal cylinder\n\\(\\Delta T\\) = difference in surface temperature and surrounding air\n\\(D\\) = diameter of cylinder\nThe convected heat transfer is given by:\n\\(Q_{conv}=h_{conv}A \\Delta T\\)\nwhere:\n\\(Q_{conv}\\) = convective heat transfer\n\\(h_{conv}\\) = heat transfer coefficient\n\\(A\\) = area of motor case\n\\(\\Delta T\\) = surface temperature with surrounding enviroment\nModeling the surface area of the generator as a cylinder with hemishpere end pieces. The diameter has been increased by 25% to account for radiating fins on the case.\n\n\nCode\nureg = pint.UnitRegistry(autoconvert_offset_to_baseunit = True) # allows for the conversion of temperatures\nmax_allowed_gen_case_temp = 80*ureg.degC\nmax_ambient_temp = 38*ureg.degC\ndelta_T = max_allowed_gen_case_temp - max_ambient_temp\n\nD = 0.190*ureg.meter # diameter of motor case\nD = D+D*0.25 # adjust the diameter by 25% to account for radiating fins on the case\nL = 0.138*ureg.meter #length of motor case\nA = np.pi*D*L + np.pi*D**2 # heat transfer surface of the generator (area of the cylinder plus end pieces)\n\nh_conv = 1.32*((delta_T.magnitude)/(D.magnitude))**(0.25)\nQ_conv = h_conv*A.magnitude*delta_T.magnitude\n#print('Q_conv: {:.2f}W'.format(Q_conv))\n\nMarkdown('The estimated convection heat flow is {:.1f} Watts.'.format(Q_conv))\n\n\nThe estimated convection heat flow is 56.6 Watts.\n\n\n\n\n4.8.1.3 Radiated heat\nThe heat transfer from radiation can be estimated from:\n\\(Q_{rad}=\\epsilon A_s \\sigma (T_s^4 - T_{surr}^4)\\)\nwhere: \\(Q_{rad}\\) = radiated heat transfer between the surface at temperature \\(T_s\\) completely surrounded by a much larger surface at temperature \\(T_{surr}\\)\n\\(\\epsilon\\) = emissivity of the surface\n\\(A_s\\) = surface area\n\\(\\sigma\\) = Stefan Boltzmann constant\n\\(T_s\\) = surface temperature\n\\(T_{surr}\\) = surrounding temperature\n\n\nCode\nemissivity = 0.85\nalpha = 5.67e-8 # Stefan-Blotzmann constant\nQ_rad = emissivity*A.magnitude*alpha*(max_allowed_gen_case_temp.to('degK').magnitude**4-max_ambient_temp.to('degK').magnitude**4)\n#print('Q_rad: {:.2f}W'.format(Q_rad))\nMarkdown('The estimated radiated heat transfer is {:.1f} Watts'.format(Q_rad))\n\n\nThe estimated radiated heat transfer is 83.5 Watts\n\n\n\n\n4.8.1.4 Heat conduction through base\nThere is heat transfer from the case to the frame through the mounting bracket.\n\\(Q_{cond}=\\frac {\\Delta T}{R}\\)\nwhere:\n\\(Q_{cond}\\) = cinducted heat transfer between mounting feet and frame\n\\(\\Delta T\\) = surface temperature with surrounding enviroment\n\\(R\\) = thermal resistance of generator base to frame\nThe thermal resistance through the PMG mouting feet to the water wheel frame is estimated to be 10 Ohms.\n\n\nCode\nR_thermal = 10 # a guess\nQ_cond = delta_T.magnitude/R_thermal\n#print('Q_cond: {:.2f}W'.format(Q_cond))\nMarkdown('The estimated conducted heat transfer is {:.1f} Watts.'.format(Q_cond))\n\n\nThe estimated conducted heat transfer is 4.2 Watts.\n\n\n\n\nCode\ntotal_heat_out = Q_conv+Q_rad+Q_cond\n#print('total heat transfered from the generator body to the enviroment: {:.1f} Watts'.format(total_heat_out))\nMarkdown('The total heat transfered from the generator body is the sum of the heat flow from the three paths, so \\\nthe total heat transfered from the generator body to the enviroment is {:.1f} Watts.'.format(total_heat_out))\n\n\nThe total heat transfered from the generator body is the sum of the heat flow from the three paths, so the total heat transfered from the generator body to the enviroment is 144.3 Watts.\n\n\n\n\nCode\ngenerator_losses_as_heat = (rho*g*Q*H*eta_waterwheel*eta_gear_box*(1-eta_generator)).to('watt')\nMarkdown('The generator produces heat internally from the winding and core losses of {:.1f~P}'.format(generator_losses_as_heat))\n\n\nThe generator produces heat internally from the winding and core losses of 211.2 W\n\n\n\n\nCode\nMarkdown('The net generator heat flow is {:.1f} Watts.'.format(total_heat_out - generator_losses_as_heat.magnitude))\n\n\nThe net generator heat flow is -66.9 Watts.\n\n\nSince the net heat flow is negative, the generator will heat up.\n\n\nCode\nureg = pint.UnitRegistry(autoconvert_offset_to_baseunit = False) # change back to more strict unit checking\n\n\n\n\n4.8.1.5 Why did the PMG generator get hot?\n\ninverter could have been in constant voltage mode with shaft to load power missmatch, wheel was spining too fast\nThe difference between available power and displayed power on the inverter was 1000 W, was that difference being dissipated as heat?\nneeded more testing to verify Kris’s complaints about the genertor, because he swapped out a 500 RPM device for a 750 RPM device w/o changing the gear box\n\nPMG winding wire diameter of 0.7 mm is probably on the low side for the 5 amps per phase calculated from the LTSpice circuit simulation of the generator windings, bridge recifier and resistive load.\n\n\n\n4.8.2 Self-excited induction generator (SEIG)\nThe third generator tried was a 2.2kW, 8 pole, induction generator from Tec Motors. This device as a motor, will make the rated power at 720 RPM. In video part 4 at time 0:51, the details on the motor face plate can be seen. See Table 10\n\n\n\nTable 10: Tec Motor generator specifications\n\n\n\n\n\nMotor part code\n2.283TECAB3\n\n\nFrame size\n132S-8\n\n\nOutput\n2.2 kW\n\n\nRotational Speed\n720 RPM\n\n\nVoltage\n230/400\n\n\nFull Load Current\n10.32 | 5.96 A\n\n\nFull Load Torque\n29.180555 Nm\n\n\n\n\n\n\nWhile the use of an induction generator is an acceptable choice, there some differences in the operation of a Self Exicted Induction Generator (SEIG). For this hydro project the primary differences are the use of capacitors across each phase to supply reactive power back to the generator, this assume that the rotor has some residual magnetism. The SEIG is physically larger and required modifications to the mounting block and weather/splash cover. The SEIG has a higher RPM than the old PMG and the gear box ratio needs to be changed to something in the area of 1:80.\nAn analysis of the SEIG will not be included in this version of my notebook. In a future version, the proposed topics are:\n\nuse of a SEIG, pros and cons\ncapacitor value calculation\nheat transfer\nuse of MPP and PV inverters\ngear ratio"
  },
  {
    "objectID": "Lake District Overshot Waterwheel Project.html#the-flume",
    "href": "Lake District Overshot Waterwheel Project.html#the-flume",
    "title": "Lake District Overshot Waterwheel ProjectReview and Analysis",
    "section": "4.9 The flume",
    "text": "4.9 The flume\n\n\n\n\n\n\nFigure 10: The flume\n\n\n\nFigure 10 was taken from part 4 of the series and shows a view of the flume after modifications were made to round the corner of the turn. You can see that the depth of the water in the flume is about 50 mm or so and that the flow rate is somewhat high since there is turbulance observed in the flow. Kris complained that wheel was turning too fast and that the generter and inverter were not slowing the wheel rotation rate. There was significant anount of splashing of the water as it entered the buckets and he built a nozzel help guide the water to the buckets. He did not address the velocity of the water compared to the tangential velocity of the wheel nor the flow rate requirements of the flume or the flume design.\nThe flume carries water from the dam to the top of the waterwheel. By examining the videos, I made some estimates for the flume dimensions. The width of the flume was about the same width of the waterwheel, which makes sense, since you want an even flow of water into the buckets. The side walls of the flume looked like 150 mm high, so this would be the maximum depth of water the could flow through the flume.\nI can use the Manning equation for open channel flow to calculate the flow rate in the flume. Mannings equation is an empirical equation that applies to uniform flow in open channels and is a function of the channel velocity, flow area and channel slope.\n\\(V = \\frac {s^{1/2} \\times R^{2/3}} {n}\\)\nwhere:\nV - water velocity\nn - Manning’s roughness coefficient; unplaned wood = 0.013, wood sides and smooth sheet metal bottom\nR - The channel’s hydraulic radius, calculated by dividing the water flow’s cross-sectional area A by its wetted perimeter P\ns - Slope of the channel’s bottom surface\nExamining Manning’s equation, we can see that the area and slope are directly proportional to the water flow rate, which means an increase in area and slope would increase the water flow rate. On the other hand, the roughness coefficient and the wetted perimeter are inversely proportional to the water flow rate, meaning that increasing their values would decrease the water flow rate.\n\n4.9.1 Flume slope\nIn Harbour (2023), Kris proided some information about the length and slope of the flume. In the survey he stated:\n\nBecause this has to be quite long (approximately 8 meters) there needs to be a downward slope in order to keep the water flowing. I have made this slope 1 degree and it equates to a 300mm level change.\n\nDoing the math to calculate the slope and level change:\n\n\nCode\nflume_length = 8*ureg.meter\nflume_drop = 300*ureg.mm\nflume_drop.ito('meter')\n\n#print('angle of slope: {:.2f}'.format(np.arctan(flume_drop/flume_length).to('degree')))\nMarkdown('The angle of slope is {:.2f}s.'.format(np.arctan(flume_drop/flume_length).to('degree')))\n\n\nThe angle of slope is 2.15 degrees.\n\n\nThe math works out to about 2 degrees.\n\n\nCode\nflume_slope = flume_drop.magnitude/flume_length.magnitude\n#print('flume slope: {:.1f}%'.format(flume_slope*100))\nMarkdown('The flume slope is {:.1f}%.'.format(flume_slope*100))\n\n\nThe flume slope is 3.8%.\n\n\nSo which is it, 1 degree or 300mm drop?\nIn the project survey, Kris goes through the verticle dimentions of the available head.\n\nThere is a drop of 2.6m from the top of the dam to the point that the outlet stream bed levels out.\n\n\nThe total head is 2.6m. Because the wheel has to be sited further down hill than the dam, there needs to be a water trough feeding the wheel. Because this has to be quite long (approximately 8 meters) there needs to be a downward slope in order to keep the water flowing. I have made this slope 1 degree and it equates to a 300mm level change. This brings the head down to 2.3m there needs to be a gap between the feed trough and the top of the wheel and this gap is 100mm. This leaves 200mm of head left. The waterwheel can’t touch the water at the bottom or it will cause drag so we need a gap there of at least 100mm now we are down to 2.1m and then I have allowed a 100mm tolerance so a 2m wheel is the correct size for this site. Though the wheel is now only 2m the other 0.5m of head is not completely lost. That 0.5m of head the water is still falling and gaining speed in the trough so the 0.5m head is not lost it is just susceptible to some friction losses in the trough.\n\nsubtractions:\n\n300 mm for the flume\n100 mm gap between top of wheel and flume\n100 mm gap at tbottem of wheel\n100 mm tolerance\n\nHere he states that the wheel of 2m is the correct size. However, eariler in the videos, he stated the wheel is 2.1 m in diameter. So a diameter of 2.1 m was used in the calculations above. Since Kris went through the gaps and tolerances to size the water wheel diameter, I’m going to assume that the slope is 0.3 meters divided by 8 meters or 3.8% and not 1 degree.\n\n\nCode\n# Flume calculations using Manning equation\nflume_width = 800*ureg.mm\nwater_depth = 70*ureg.mm # estimated depth of the water in the flume\n# convert to base units\nflume_width.ito('meter')\nwater_depth.ito('meter')\nwater_cross_section_area = water_depth*flume_width\nwetted_perimeter = 2*water_depth+flume_width\nhydraulic_radius = water_cross_section_area/wetted_perimeter\nroughness_coefficient = 0.013 # Wood - unplaned\nslope = flume_slope\n# need to use magnitude of quantity when using fractional exponents\nwater_flume_velocity = (((hydraulic_radius.magnitude)**(2/3)*slope**(1/2))/roughness_coefficient)*ureg.meter/ureg.sec\nvolumetric_flow_rate = water_flume_velocity*water_cross_section_area\n\ntable_header = ['Calculation', 'Result']\ntable_row = []\ntable_row.append(['Water cross section area', '{:.2f~P}'.format(water_cross_section_area)])\ntable_row.append(['Wetted perimeter', '{:.2f~P}'.format(wetted_perimeter)])\ntable_row.append(['Hydraulic radius', '{:.2f~P}'.format(hydraulic_radius)])\ntable_row.append(['Slope', '{:.1f}%'.format(slope*100)])\ntable_row.append(['Water flume velocity', '{:.1f~P}'.format(water_flume_velocity)])\ntable_row.append(['Volumetric flow rate', '{:.2f~P}'.format(volumetric_flow_rate)])\ntable_row.append(['Volumetric flow rate', '{:.2f~P}'.format(volumetric_flow_rate.to('liter/sec'))])\n\nMarkdown(tabulate(table_row, headers=table_header,colalign = ('left','left'),tablefmt=\"simple\"))\n\n\n\n\nTable 11: Flume calculations using Manning equation\n\n\n\n\n\n\nCalculation\nResult\n\n\n\n\nWater cross section area\n0.06 m²\n\n\nWetted perimeter\n0.94 m\n\n\nHydraulic radius\n0.06 m\n\n\nSlope\n3.8%\n\n\nWater flume velocity\n2.3 m/s\n\n\nVolumetric flow rate\n0.13 m³/s\n\n\nVolumetric flow rate\n127.24 l/s\n\n\n\n\n\n\n\n\n\nThe values calculated by Manning’s equation are estimates, so we should get too hung up on the magnitudes, but the these numbers can serve as a guide to what’s happing in the flume. Given the roughness coefficient and slope, the water velocity is above 2 m/s and in the videos, the water at high flow rates is moving fast. The velocity of the water definately exceeds the tangential velocity of the water wheel and it is appearent in the videos that lots of water is slpashing out of the buckets when Kris tries to run the hydro system at full power. Some adjustments to the flume are needed.\n\n\n4.9.2 Flume re-design\nTo avoid a total rebuild of the flume, some modifications could be made to decrease the flow velocity while maintaing the desired flow rate. The slope of the flume is kept, since the slope would be hard to change. The inlet depth would need to be increased to allow a deeper flow and baffles or corrugated surface could be installed to line the bottem channel of the flume. This would cause some energy dissipation and slow the flow characteristics. In the calculations below the water depth and roughness coefficient were adjusted. Modifications to the flume surface roughness would need to proceed by trial and error until the right combination of water depth and surface roughness yeilds the desired flow velocity and volume.\nThe inlet to the flume is adjust to bring the depth in the flume channel up to 150mm. The inlet level to the spillway might need to be raised and along with the flume side walls to rase the level of water entering the flume. The surface roughness coefficient needs to be increased by adding baffles. The calculations below produce a flow velocity of 1 m/s and a volume of 132 l/s.\n\n\nCode\nflume_width = 800*ureg.mm\nwater_depth = 150*ureg.mm\n# convert to base units\nflume_width.ito('meter')\nwater_depth.ito('meter')\nwater_cross_section_area = water_depth*flume_width\nwetted_perimeter = 2*water_depth+flume_width\nhydraulic_radius = water_cross_section_area/wetted_perimeter\nroughness_coefficient = 0.04 # increased by adding baffles\nslope = flume_slope\n# need to use magnitude of quantity when using fractional exponents\nwater_flume_velocity = (((hydraulic_radius.magnitude)**(2/3)*slope**(1/2))/roughness_coefficient)*ureg.meter/ureg.sec\nvolumetric_flow_rate = water_flume_velocity*water_cross_section_area\n\ntable_header = ['Calculation', 'Result']\ntable_row = []\ntable_row.append(['Water cross section area', '{:.2f~P}'.format(water_cross_section_area)])\ntable_row.append(['Wetted perimeter', '{:.2f~P}'.format(wetted_perimeter)])\ntable_row.append(['Hydraulic radius', '{:.2f~P}'.format(hydraulic_radius)])\ntable_row.append(['Slope', '{:.1f}%'.format(slope*100)])\ntable_row.append(['Water flume velocity', '{:.1f~P}'.format(water_flume_velocity)])\ntable_row.append(['Volumetric flow rate', '{:.2f~P}'.format(volumetric_flow_rate)])\ntable_row.append(['Volumetric flow rate', '{:.2f~P}'.format(volumetric_flow_rate.to('liter/sec'))])\n\nMarkdown(tabulate(table_row, headers=table_header,colalign = ('left','left'),tablefmt=\"simple\"))\n\n\n\n\nTable 12: Flume redesign\n\n\n\n\n\n\nCalculation\nResult\n\n\n\n\nWater cross section area\n0.12 m²\n\n\nWetted perimeter\n1.10 m\n\n\nHydraulic radius\n0.11 m\n\n\nSlope\n3.8%\n\n\nWater flume velocity\n1.1 m/s\n\n\nVolumetric flow rate\n0.13 m³/s\n\n\nVolumetric flow rate\n132.64 l/s"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "References"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This site is a collection of Jupyter Notebooks describing problems solved with the aid of Python and the SciPy, SymPy, NumPy, Pandas and Matplotlib libraries. Jupyter notebooks are documents that allow code and markdown text to be contained in the same document and provides an excellent way to document the analysis and results of the problem solving effort.\nThis site was built using JupyterLab notebooks and Quarto, which is an open-source scientific and technical publishing system."
  },
  {
    "objectID": "password_card.html",
    "href": "password_card.html",
    "title": "Password card",
    "section": "",
    "text": "last update: 2 Feb 2023"
  },
  {
    "objectID": "password_card.html#abstract",
    "href": "password_card.html#abstract",
    "title": "Password card",
    "section": "Abstract",
    "text": "Abstract\nThis notebook describes the use of a password card and the Python code that generates the password card. The password card is a grid of random letters, numbers and special characters that provides a convenient aid to generate and remember long and complex passwords. A basic description of the password card and instructions are provided along with the Python code used to generate the password card. A security analysis and an analysis of alternatives is provided."
  },
  {
    "objectID": "password_card.html#motivation",
    "href": "password_card.html#motivation",
    "title": "Password card",
    "section": "Motivation",
    "text": "Motivation\nComing up with secure passwords and remembering a unique password for each account is a challenge. The safest way to store your passwords is to memorize them, but for long and complex passwords this is not practical. Passwords that humans can remember and use are guessable. The password card described in this notebook is a paper card that once generated is off-line, an independent record of your passwords and is protected by a secret word that you memorize. In one sense, the password card is a Password manager, but it is not computerized."
  },
  {
    "objectID": "password_card.html#introduction",
    "href": "password_card.html#introduction",
    "title": "Password card",
    "section": "Introduction",
    "text": "Introduction\nThis notebook describes the generation and use of a password card similar to the card called “C@RD”, a laminated card sold by Russtopia Labs for $4.25. The password card provides an easy way to generate and remember long and complex passwords. The version of the card described here has the upper case letters of the alphabet printed on line number one of the card. The card consists of an array of letters, numbers and special characters that can be used as passwords for web pages and can be printed on a credit-card sized piece of paper which can be laminated and carried in your wallet or pocket. A sample card is shown below:\n\nThe first three rows are the upper case letters of the alphabet, the lower case letters, the special characters and numbers used on the card. All the characters used in the passwords are printed here as a reference since for some fonts, some characters are hard to distinguish, for example, l and 1. Rows four through nine are random combinations of the letters of the alphabet, numbers and special characters. The columns of rows four through nine contain the characters used in the passwords and each column contains at least one uppercase letter, one lowercase letter, one digit and one special character in addition to two randomly selected characters, for a total of six characters. The last row on the card is a random sequence of numbers that can be used for numerical PINs.\nThe passwords for your accounts are generated from two parts, the first part of your password comes from the card, the second part is a secret word, committed to memory, consisting of a combination of letters, numbers or special characters that only you know. When combined, the combination yields passwords which are complex and of adequate length for most applications.\nGood passwords have the following characteristics:\n\nThey do not contain personal information or common words\n\nThey do not contain words or phrases from songs lyrics, poetry, literature etc.\n\nThey are long enough to resist brute force guessing attacks from current and future password cracking systems\n\nThey are not from a list of previously compromised passwords e.g. names, names with numbers or symbols, words from dictionaries etc.\n\nThey do not contain simple substitutions such as @ for a, 5 or $ for s, 1 for i, etc.\n\nWhich implies that the password should be random, not easily guessed and as a result can be hard to memorize.\n\nUnique passwords for each account\nEach account should have a unique password. If the same password is used for multiple accounts, then all accounts using that same password are vulnerable if your reused password is compromised. This advice is almost universally given by security experts and journalists who write on the subject. Credential stuffing is a type of cyber attack in which the attacker collects stolen account credentials, typically consisting of lists of usernames and/or email addresses and the corresponding passwords (often from a data breach), and then uses the credentials to gain unauthorized access to user accounts on other systems through large-scale automated login requests directed against a web application. Unlike credential cracking, credential stuffing attacks do not attempt to use brute force or guess any passwords – the attacker simply automates the logins for a large number (thousands to millions) of previously discovered credential pairs using standard web automation tools. The best way to protect against credential stuffing is to use unique passwords on accounts.\n\n\nOther password cards\nThe following are links to other types of password cards.\n\nPasswordCard: The user picks a row and column and reads the password in the direction chosen. Could be left, right or diagonal.\n\nPassword card generator: You can pick on a row, a column, click on random characters and/or draw images on your Password Card that are easy to remember.\n\nPassCard: similar to PasswordCard above\n\nPasswordWrench: similar to Password card generator above\n\nQwertycards: the password is a character substitution cipher of the web site’s name.\n\n\n\nCanadian patent\nThe “C@RD” from Russtopia Labs was designed and patented in Canada and was protected under Canadian patent number 2,895,597. In 2016 and 2019 the patent expired due to failure to respond and failure to pay application maintenance fee."
  },
  {
    "objectID": "password_card.html#password-card-instructions",
    "href": "password_card.html#password-card-instructions",
    "title": "Password card",
    "section": "Password card instructions",
    "text": "Password card instructions\nInstructions for the use of the card are provided by Russtopia Labs and are summarized here.\n\nChoose a secret word or phrase known only to you. This ensures that even if your password card is lost or stolen, no one will know the full password you generate from the card.\n\nUsing the first two letters of the website or name of the company holding your account, choose the appropriate columns and read downwards in rows four through six. Every column has at least one letter (both upper- and lower-case), a digit and a special character.\n\nThe image below, shows the card with sections highlighted in colored boxes.\n\nPasswords are generated by using the first two letters of the website or company holding your account and then reading down the columns of rows four through six. If the web site is amazon.com, choose columns “A” and “M”, and read the characters from rows four through six. These are highlighted in the black and blue boxes. In column “A” (in blue), the characters are “8@%yP!”, and in column “M” (in black), the characters are “kfoC?2”. If your personal secret word is “apple”, then the full password for your amazon account would be “8@%yP!kfoC?2apple”, which is a complex 17 character password containing upper and lower case letters, digits and special characters. Since you know the procedure, you don’t have to remember the 17 characters, just use the procedure along with your card to reconstruct your password.\n\nRotating passwords\nFor rotating passwords, add two characters from rows four and five of numbered columns in row 3, (01=Jan), (02=Feb), for each month. (eg., in row four, two characters in column for 1st month digit, then two characters in column for 2nd month digit, February=02, under 0 in row four, read “5e”. Then under 2 in row five, read “dA” and prefix to password. The resulting password would be “5edA” plus the remaining base password, “5edA8#&yP!kfoC?2apple”. In three months or whenever the password expires, use the month to generate a new prefix. This is the procedure outlined by Russtopia Labs.\nSome sites will check to see if the new password is sufficiently different than, say for example, the last ten passwords used. If the passwords are stored as a hashed value, then any difference, even one character difference would be sufficient. But if the prior passwords are stored as plain text or in an encrypted file, the system could check the degree of difference between old passwords and the new one. So if the site is enforcing a new password that is different from your old password by some amount of characters, then the following procedure can be used.\nAt the beginning of the year, in January for example, if a new password is required, construct the new password as follows: - The months are numbered from 1 to C as shown in the table below and the characters are from the column under that month number or letter. So in January, month number 1, use the characters from column 1 which are: 3bXz%f. - The next characters are from column A and M (for Amazon), but only three characters from each column are used: A = 8@% and M = kfo. - Then append your secret word.\n\n\n\nmonth\ncol #\ncol chars\nA col\nM col\nsecret word\n\n\n\n\nJan\n1\n3bXz%f\n8@%\nkfo\napple\n\n\nFeb\n2\ndAk)$1\n8@%\nkfo\napple\n\n\nMar\n3\n?y(1?J\n8@%\nkfo\napple\n\n\nApr\n4\n*-1@Ui\n8@%\nkfo\napple\n\n\nMay\n5\n66!A$b\n8@%\nkfo\napple\n\n\nJun\n6\n&jcPQ6\n8@%\nkfo\napple\n\n\nJul\n7\nmrc3B#\n8@%\nkfo\napple\n\n\nAug\n8\n&gt;&lt;^nJ7\n8@%\nkfo\napple\n\n\nSep\n9\n5DktW&lt;\n8@%\nkfo\napple\n\n\nOct\nA\n8@%yP!\n8@%\nkfo\napple\n\n\nNov\nB\nX4Mz+b\n8@%\nkfo\napple\n\n\nDec\nC\nax!p2M\n8@%\nkfo\napple\n\n\n\nA new password for January would be: 3bXz%f8@%kfoapple. In April, if the password has to be changed, it would be: *-1@Ui8@%kfoapple. You only need to remember in which month you created the new password.\n\n\nNumeric PIN\nFor a numeric PIN, pick a letter and start with that number in the random number row. For example, if your bank is Commerce Bank, under the letter “C” in the first row, the PIN numbers are “141845” (red highlight). You can use four numbers if you want.\nFor sites that restrict the number of characters in the password, choose a 4-letter secret word and only read the first two or three symbols from each column in Step 2) above. This will give you an 8 or 10 character password to meet password restrictions of old systems.\n\n\nRestricted characters\nFor sites with restrict the use of special characters, read the columns as usual but each time you encounter a prohibited special character, use a letter instead (for example, “&lt;” becomes “n”, “&gt;” becomes “o” etc.) which are the letters in row two directly above the special characters in row three.\nIf the website or account has repeated letters, for example “aa.com”, this would result in using the same column “a” twice, which according to the original procedure is acceptable. However if you feel uncomfortable using a password with any repeated sequences, shift to the left or right adjacent column for the second letter – in essence treating “aa” as “ab” (second “a” becomes “b”).\nTypically, a user would keep a list of web page names and the corresponding user name, web site letter code and notes. The user would refer to this list for websites that are not often used or have restricted characters. The user would refer to the list until it became committed to memory.\n\n\nSecret word selection\nThe purpose of the secret word is to keep at least part of your password secret in the event that someone finds your password card. The secret word part is memorized and not written down anywhere. In the examples above, the secret word used was “apple”. You should use something different.\nThere are about 255 thousand defined words in the Merriam-Webster’s Collegiate Dictionary English dictionary, choosing one random word out of a dictionary provides about 17 bits of entropy. Your secret word should have at least 30 bits of entropy, in order to prove a modest level of security. One random word would provide a bit of security that might keep a nosy family member out of your email account if they “borrowed” your password card. Two random words concatenated would provide about 35 bits of entropy, enough to keep even the most determined family member out of your email account. For example the two words, “program” and “blind” could be concatenated to generate a secret passphrase, “programblind”.\nMultiple random words concatenated is called a passphrase. The more words that are in the passphrase, the more secure it is, but harder to memorize. To prevent personal bias from affecting your choice of words you could use dice to aid in choosing words from the dictionary. Roll some dice and choose a dictionary page number based on the dice rolls. Roll the dice some more and choose a word on the page. Repeat until you have the number of words you want. One way to harden short passphrases is to mangle the passphase, for example “programblind” could be mangled to be “pRogram=bli2nd”. Not impossible to memorize, but nearly impossible to guess. With the password card, “pRogram=bli2nd” is the only part you need to commit to memory."
  },
  {
    "objectID": "password_card.html#python-code",
    "href": "password_card.html#python-code",
    "title": "Password card",
    "section": "Python Code",
    "text": "Python Code\nThis section of the notebook contains the Python code used to generate the password card. The Python library Secrets is used to randomly choose elements from the character set. The secrets module is used for generating cryptographically strong random numbers suitable for managing data such as passwords, account authentication, security tokens, and related secrets.\nThe Python code described below can be used to generate a unique card for each person.\n\nimport math\nimport sys\nimport re\nimport hashlib\nimport secrets\ngen = secrets.SystemRandom()\nfrom collections import Counter\nimport matplotlib.pyplot as plt\n\n\nfrom sympy.solvers import solve\nfrom sympy import Symbol\n\n\nCharacter set\nThe following characters are used in the password card. Upper and lowercase letters of the alphabet, the digits 0 to 9, as well as the so-called special characters are used. A special character is one that is not considered a number or letter. Special characters are often required when creating a strong password. This is because they add complexity to the password. There are 33 characters classified as ASCII punctuation and symbols are also sometimes referred to as ASCII special characters.\nThe special characters used in this notebook are: !@#$%^&*()-+=&lt;&gt;?\nHowever, other characters from the keys on a typical US standard keyboard could also be used: ~!@#$%^&*()_+-=,./&lt;&gt;?;’:“[]{}|\nAny of these could be easily substituted to give the password card additional variation. Up to 16 special characters will fit into the scheme.\n\nlower = 'abcdefghijklmnopqrstuvwxyz'\nupper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\ndigits = '0123456789'\nspecial = '!@#$%^&*()-+=&lt;&gt;?'\nchar_set_size = len(upper)+len(lower)+len(digits)+len(special)\nprint('character set size: {:d}'.format(char_set_size))\n\ncharacter set size: 78\n\n\n\n\nSet the number of rows\nThe number of rows in the random part of the password card is set to 6, as in the original card. Variations of the password card could be made with a different number of rows.\n\nnum_rows = 6\n\n\n\nPrint character sets as first three lines of the card\nThis provides a visual reference since in some fonts characters l and 1, and 0 and O, are hard to tell apart.\n\n# print character sets as first three lines of the card\nprint(upper)\nprint(lower)\nprint(special+digits)\n\nABCDEFGHIJKLMNOPQRSTUVWXYZ\nabcdefghijklmnopqrstuvwxyz\n!@#$%^&*()-+=&lt;&gt;?0123456789\n\n\n\n\nGenerate the password random characters\nEvery column has one upper, one lower, one digit and one special character, followed by two random characters from the complete set. And when two columns are used, the password has at least two lower case, two upper case, two digits and two special characters.\n\nA=[]    #make empty list for random characters\nfor j in range(26):\n    temp = '' # make an empty character string\n    temp += secrets.choice(lower)\n    temp += secrets.choice(upper)\n    temp += secrets.choice(digits)    \n    temp += secrets.choice(special)      \n    # add more random characters\n    for i in range(num_rows-4):\n        temp += secrets.choice((lower + digits + upper + special))  \n    # take the list and randomize the order\n    temp = secrets.SystemRandom.sample(gen, temp, num_rows)\n    A.append(temp)\n\n#printing the rows of the password card\nfor i in range(num_rows):\n    for j in range(len(lower)):\n        print(A[j][i],end='') # end='' does not print new line for each call to print\n    print()\n\nDBpb^L#!5!EwNedd49ZGvgdZ9t\nIl2!p=%u&lt;JXJ#Ce#&gt;N(eO!nukb\nbd)(Kr2XJmv@i=5Bwz5F2jn5K$\n%GY18u^4A02893$s)-+$wR7%M0\nR8&gt;uu^zEe)@T$8H7JhGI!XZh&gt;P\n7&lt;DH=8Jy&gt;mScOxE2M+c6v0(-=-\n\n\nThe block of text can be copied into a document to save the results. Every time the code above is run, a new block of random characters is generated.\n\n\nRandom row of digits\nThe last row in the password card is a row of random digits which can be used for PIN’s.\n\n#print a row of random numbers\ntemp = ''\nfor i in range(26):\n    temp += secrets.choice(digits)\nprint(temp)\n\n28463178520723307301568482\n\n\nCopy the rows of the password card to a word document for formatting and printing. The card works best if every other column is highlighted to make reading easier.\nABCDEFGHIJKLMNOPQRSTUVWXYZ\nabcdefghijklmnopqrstuvwxyz\n!@#$%^&*()-+=&lt;&gt;?0123456789\n)0A4+^ZYwAk17%21?33F(NOo94\n72!5dFZzgCN^t9@oqiISqlq1Da\njDbVqD3N-4&lt;yiInG!c-0ddW$rR\nU!8!U5c0X&gt;soys*)*Zx?M-?I?#\nbE7l7m$b9o0E&%OoFVWh$fwI%@\nEvyR-&lt;f&gt;?)qQD*hW2)V9457$@N\n85640243163554984484266573\n\n\nSecret word\nThe secret word is the part of your password that you commit to memory. It doesn’t change, you only have to memorize this part. In the example the secret word is “apple”, but as discussed above is not sufficient. The following code uses simulated dice rolls to choose two random words from a list such as list of English words (479k words) to construct a pass phrase and then mangles the passphrase to defend against dictionary attacks.\nThe word list file is read in and filtered by length. Words with spaces, all caps and punctuation are also removed from the list.\n\nwords = []\nmin_length = 5\nmax_length = 9\nvalid_chars = '.'\nregexp = re.compile(\"^{0}{{{1},{2}}}$\".format(valid_chars,min_length,max_length))\n\n# read words from file into wordlist\nwith open('wordlist.txt') as wlf:\n    for line in wlf:\n        thisword = line.strip()\n        if regexp.match(thisword) is not None:\n            words.append(thisword)\n\n# remove words with spaces, all caps, and words with punctuation\ntemp_list = []\nfor i in words:\n    if not i.isupper() and i.isalpha():\n        temp_list.append(i)\n\nThe words in the list are shuffled since the selection later is somewhat Gaussian and would tend to pull words from the middle of the list.\n\nwordlist = []\nwhile len(temp_list) &gt; 0:\n    picked_item = secrets.choice(temp_list)\n    wordlist.append(picked_item)\n    temp_list.remove(picked_item)\n\n\n# number of bits to use in the index\nnum_bits = 15\n# check to see if word list is long enough\nlen(wordlist) &gt; 2**num_bits\n\nTrue\n\n\nThe fill list is trimmed so that the length is equal to \\(2^{\\text{number of bits}}\\)\n\nabridged_wordlist = wordlist[0:2**num_bits]\nprint('number of words in the abridged word list: {:,.0f}'.format(len(abridged_wordlist)))\n\nnumber of words in the abridged word list: 32,768\n\n\nThe first 150 words in the abridge_wordlist are:\n\ni=0\nfor j in range(10):\n    for k in range(15):\n        print(abridged_wordlist[i]+' ',end='')\n        i += 1\n    print()\n\nunholy grasp bucketful Phrygia worthily progeny Sporades reprimand thank Saroyan dimorphic muddler deadbolt ablative Cameroun \nsquid dyestuff arisen bedbug trimmer writhe filled telegraph annoyed buddy gerbil chilblain liberty garrison sissy \ncologne offerer nescient Saturn Giorgione excess armor deviation pillared Midianite waddler remover pressed Canopus flivver \nconductor Kodiak denseness bleep humanely smoke Rajasthan settlor wastrel languid muniments exhale aquatic disputant Lotty \nextensor absconder nighthawk crinkled Deity outdrawn Casper paisley glitzily roughneck convey forced rinse ennead elongate \ntwisty sacristan quirkish mangily inanity euthenist catacomb wrote shielder colors Multan conjurer fielder pinones vincible \nmason shield demit gumption Cather clearing craton camping Bayreuth taunter reddish otiose mercurous Mindanao saver \nmisgiving paramount catholic recession hermetic Garfield rhubarb mezuzot atheneum rivet rubric trumps gloaming Scythian unwearied \nCheever diaspora immolator vitiation Fatima ironware copacetic metonym medically nonrandom uniformed sickroom sands Thermos freeboard \nclerk samba kennel katakana tinniness adequate gelidness gauche Ockham graham gleaming crafty sextuply equipment groove \n\n\nAs shown above the words in the abridge list are not in alphabetical order.\n\nprint('the abridged list includes words from \"{:s}\" to \"{:s}\"'.format(min(abridged_wordlist),max(abridged_wordlist)))\n\nthe abridged list includes words from \"Aachen\" to \"zymurgy\"\n\n\nThe following code simulates dice rolls. Actual dice could be used and the results entered into the code below.\n\nnum_rolls = 50\nprint('{:d} dice rolls have an entropy of: {:.0f} bits'.format(num_rolls, math.log2(6**num_rolls)))\n\n50 dice rolls have an entropy of: 129 bits\n\n\n\n# generate n dice rolls\nrd_str = ''\nfor i in range(num_rolls):\n    rd_str += secrets.choice('123456')\n\nprint('the string of {:d} dice rolls: {:s}'.format(num_rolls,rd_str))\n\nthe string of 50 dice rolls: 61364161135455555344544644535134366221166665211245\n\n\nPhysical dice can be rolled and the digits copied into the string variable.\n\nDice value frequency\nThe following graph checks the dice value frequency, it should be somewhat uniform and there should be no missing digits. This is a useful graph if you are rolling physical dice and entering the results into the program.\n\n# using collections.Counter() to get a count of the occurrence of each digit in string  \nmgram = Counter(rd_str) \n\nsorted_dict = {key: value for key, value in sorted(mgram.items())}\n\nplt.bar(range(len(sorted_dict)), sorted_dict.values(), align='center')\nplt.xticks(range(len(sorted_dict)), list(sorted_dict.keys()))\nplt.show()\n\n\n\n\n\n\n\n\nUsing the above graph to check the distribution of digits, which should appear somewhat uniform and at least there should be no missing digits. The list of dice rolls is converted into an integer by hashing the string, that way all the dice rolls are used.\n\nm = hashlib.sha256()\nm.update(rd_str.encode('utf-8'))\nprint('the hashed value of the dice roll string: {:s}'.format(m.hexdigest()))\n\nthe hashed value of the dice roll string: 7addf3166b03eb514a20c3d3067a4d72773156f03ea1b52bb36101ec14135ee6\n\n\n\nrn_int = int(m.hexdigest(),base=16)\nprint('convert the hashed value into an integer: {:d}'.format(rn_int))\nprint('length of digit string: {:d} characters'.format(len(str(rn_int))))\n\nconvert the hashed value into an integer: 55574318457225646580354742707503127334411965880144442585010388745071996657382\nlength of digit string: 77 characters\n\n\n\n\nDigit frequency\nThe following graph displays the digit frequency of the converted integer.\n\n# using collections.Counter() to get a count of the occurrence of each digit in string  \nmgram = Counter('{:d}'.format(rn_int)) \n\nsorted_dict = {key: value for key, value in sorted(mgram.items())}\n\nplt.bar(range(len(sorted_dict)), sorted_dict.values(), align='center')\nplt.xticks(range(len(sorted_dict)), list(sorted_dict.keys()))\nplt.show()\n\n\n\n\n\n\n\n\n\nprint('number of bits in the number: {:d}'.format(len('{:b}'.format(rn_int))))\n\nnumber of bits in the number: 255\n\n\n\n# number of words to use in the pass phrase\nnum_words = 2\n\nThe words in the word list are indexed by taking 15 bits at a time from the number generated from the hashed dice string.\n\nprint('number of words that can be indexed with hashed value: {:.0f}'.format(len('{:b}'.format(rn_int))/num_bits))\n\nnumber of words that can be indexed with hashed value: 17\n\n\n\npass_phrase = ''\nfor i in range(num_words):\n    pass_phrase += abridged_wordlist[(rn_int &gt;&gt; num_bits*i) & 2**num_bits-1]\n    print('{:2d}: {:5d} = {:s}'.format(i+1, (rn_int &gt;&gt; num_bits*i) & 2**num_bits-1, abridged_wordlist[(rn_int &gt;&gt; num_bits*i) & 2**num_bits-1]) )\nprint(pass_phrase)\n\n 1: 24294 = betters\n 2: 10278 = donut\nbettersdonut\n\n\nMangle the passphrase to defend against dictionary attacks.\nCheck for any caps, if not add one in a random place\n\nif pass_phrase.islower():\n    i = secrets.randbelow(len(pass_phrase))\n    pass_phrase = pass_phrase[:i] + pass_phrase[i].upper() + pass_phrase[i+1:]\npass_phrase\n\n'betTersdonut'\n\n\nInsert random special and random digit into the passphrase.\n\ni = secrets.randbelow(len(pass_phrase))+1\nmangled_pass_phrase = pass_phrase[:i] + secrets.choice(special+digits) + pass_phrase[i:]\ni = secrets.randbelow(len(mangled_pass_phrase))+1\nmangled_pass_phrase = mangled_pass_phrase[:i] + secrets.choice(special+digits) + mangled_pass_phrase[i:]\nmangled_pass_phrase\n\n'betTe4rsdo(nut'\n\n\n\nprint('length of mangled passphrase {:d}'.format(len(mangled_pass_phrase)))\n\nlength of mangled passphrase 14\n\n\nEvery time the code is run, a new selection of words is made. On a previous run, the randomly chosen words were:\n1: 16611 = avowedly\n2: 5383 = hesitance\navowedlyhesitance\nOne generated example: ‘a@vowedlyhesitAn0ce’\nlength of mangled passphrase 19\nThis passphrase of 19 characters, is two random words and has a random capital letter, symbol and number inserted into the string of letters at random positions. The particular pass phrase “a@vowedlyhesitAn0ce” is but one instance in a vast pool of possible passphrases built with the algorithm. The hacker would need to try a vast number of three word combinations with a random capital letter, symbol and number inserted into the string of letters at random positions."
  },
  {
    "objectID": "password_card.html#implementation-and-use-of-the-password-card",
    "href": "password_card.html#implementation-and-use-of-the-password-card",
    "title": "Password card",
    "section": "Implementation and use of the password card",
    "text": "Implementation and use of the password card\nMy recommendation is not to use the password card for financial, email accounts or highly used social media accounts. These accounts, which are high value, and which I’ll call Tier 1 accounts, should have 16 to 20 character random character strings used as passwords. Tier 1 passwords should be written in a password book and kept secure. Furthermore, a dedicated computer should be used for financial Tier 1 accounts, not one that has been used for general web surfing and might have become infected from daily contact with the internet.\nGenerating the password card requires a computer and the ability to run the Python code shown in this notebook. The computer has most likely been connected to the internet at some time or is currently connected to the internet. This may not be acceptable if you have a high level of paranoia. Most people would be OK with generating, printing the card and then deleting or encrypting the backing up the files. A password card can be printed by copying the grid of characters to a word document for formatting and printing. Highlight alternate columns and font to Courier New size 12 for printing and lamination. Making an encrypted copy of the password card word document would probably be OK for most people. The printer and home computer are behind a locked door and the generation and use of the password card can be kept relatively private. After the card is printed, it could be laminated to make it more durable. You can find instructions for laminating cards online by using a household iron.\nThe secret phrase used with the password card should be written down somewhere until it becomes committed to memory. Additionally, 2FA should be enabled wherever it is available."
  },
  {
    "objectID": "password_card.html#security-analysis",
    "href": "password_card.html#security-analysis",
    "title": "Password card",
    "section": "Security analysis",
    "text": "Security analysis\nThe purpose of this section is to perform an analysis of the password card and look at the security properties. A hacker will try to exploit exploit weaknesses found in the design or usage of the password card. Two common analysis techniques are black-box and white-box analysis.\nA black-box analysis is an attack that works independently of the password algorithm. The most common black-box analysis is the brute-force search, where all known combinations are tried. A modified version is to try weak or short passwords, rather than an exhaustive search.\nThe opposite of a black-box analysis is a system where the inner components or logic are available for inspection. This is commonly referred to as a white-box or glass-box. This looks at the analysis from the point of view that the attacker knows how the algorithm works.\nThe security analysis will look at both points of view, with zero knowledge and complete knowledge.\n\nAnalysis of password card random characters\nAs described above, the secrets library can be used to generate the password’s random characters. The selection of letters, numbers and special characters is cryptographically random. Variations in the character set usually involve choosing the special characters. In this notebook, the following character sets are used.\n\n\n\ncharacter set\n\n\n\n\n\nlower\nabcdefghijklmnopqrstuvwxyz\n\n\nupper\nABCDEFGHIJKLMNOPQRSTUVWXYZ\n\n\ndigits\n0123456789\n\n\nspecial\n!@#$%^&*()-+=&lt;&gt;?\n\n\n\nThe random part of the password card contains a random selection of: 2 upper + 2 lower + 2 digits + 2 special + 4 random, the number of combinations is:\n\n# password card combinations\npwc_combinations = len(lower)**2 * len(upper)**2 * len(digits)**2 * len(special)**2 * char_set_size**4\nnum_of_chars = 12\nprint('possible combinations of {:d} characters in the password card is {:,.3e}'.format(num_of_chars, pwc_combinations))\n\npossible combinations of 12 characters in the password card is 4.330e+17\n\n\nChoosing the 12 random characters in the way that is used to generate the password card limits the number of possible combinations.\nAn adversary could attack the first six characters of the password since the first six characters only contain one upper case, one lower case, one special and two random characters. This was done to satisfy restrictive password policies. The second six characters are constructed similarly. This means that the password card will have at most three uppercase characters in the first group. Similarly, the same goes for lower case, digits and specials. This limitation can be exploited and reduce the search space. The code generating the password card will include at least one character from each group, but as a consequence, strings of five digits are excluded. This means that not all possible combinations are included in the password.\nThe calculation below shows that the number of combinations of 12 characters, if all combinations are allowed, is about five orders of magnitude larger than available on the password card.\n\nnum_of_chars = 12\nprint('combinations of {:d} characters from a character set of {:d} is {:,.3e}'.format(num_of_chars,\n    char_set_size,char_set_size**num_of_chars))\n\ncombinations of 12 characters from a character set of 78 is 5.071e+22\n\n\n\n\nAnalysis of secret word space\nThe secret word, since it consists of two words concatenated, is called a passphrase. There are 32,768 five to nine character long words in the abridged word list. Most people will tend to pick shorter words or familiar words. Using dice will prevent this tendency from happening and being exploited.\n\nwordlist_size = len(abridged_wordlist)\nprint('The number of combinations of two random words from the word list is {:,.3e}'.format(wordlist_size**num_words))\n\nThe number of combinations of two random words from the word list is 1.074e+09\n\n\nAdditionally the passphrase is mangled. The passphrase is two random words of minimum length of 5 characters, with word mangling, therefore not directly in any dictionary. The word mangling is obtained by randomly converting one character to uppercase, if there is not one already and inserting a random digit and special character into the passphrase. This will force the password cracker to exhaustively search the entire space of possibilities, since no substitution rules were followed.\nTo calculate the size of the passphrase space, we need to consider how many items there are. - There are two random words taken from a list of \\(2^{15}\\) words - There are two random characters inserted from a list of 26 digits and special characters - One character is converted to an uppercase if there is not already a upper case\n\nprint('number of items: {:,d}'.format((wordlist_size)**num_words + len(special) + len(digits)))\n\nnumber of items: 1,073,741,850\n\n\nThere are two words and two special or digits selected from the number of items.\n\nsecretword_space = (len(abridged_wordlist)**num_words + len(special) + len(digits))**(num_words+1+1)\nprint('secret word space: {:.3e}'.format(secretword_space))\n\nsecret word space: 1.329e+36\n\n\nCan also look at secret word space from the point of view as if it were 12 to 20 random characters.\n\nprint('Min secret word space, if considered as random chars: {:.3e}'.format(char_set_size**12))\nprint('Max secret word space, if considered as random chars: {:.3e}'.format(char_set_size**20))\n\nMin secret word space, if considered as random chars: 5.071e+22\nMax secret word space, if considered as random chars: 6.949e+37\n\n\nSeems like calculating secret word space based on the way the secret word is built should generate a space between the limits.\n\n\nAnalysis of password card PIN\nThe PIN digits are not protected by any additional secrets. Someone who has access to your password card can read your PIN’s directly. For example, if you lose your wallet containing your ATM card and your password card, someone can use the card to access your funds. To defend against this, you could offset the PIN numbers used either by physical position or by adding modulo 10 some secret offset. In other words, actual PIN’s are shifted left or right by some position or the numbers offset in value by some amount; or maybe both."
  },
  {
    "objectID": "password_card.html#threat-model",
    "href": "password_card.html#threat-model",
    "title": "Password card",
    "section": "Threat model",
    "text": "Threat model\nIn this section attacks against passwords will be examined. A password or passphrase is typically a string of characters or a list or words, that can be random and is a secret shared between the individual and the computer system that confirms their identity.\nThreat modeling is a risk analysis exercise where potential threats and mitigations are identified. In this notebook I’ll be looking at threats directly made on the password itself.\n\nAttacks against passwords\nPhishing, Man-in-the-Middle and Key-Logging attacks attempt to steal the password as does the so-called “$5 wrench attack”. Because these attacks do not exploit a weakness in the password itself, they are not covered in this analysis. Mitigations against password cracking threats will be discussed.\nCredential Stuffing: Credential based attacks occur when attackers use previously cracked passwords at many different sites, looking for passwords that have been re-used.\nDictionary attacks: Password lists, Dictionary, word mangling: These attacks occur when attackers use dictionary lists of known cracked passwords, dictionary words and word mangling to attempt to guess passwords.\nBrute force: This attack involves trying all combinations of characters up to some limit, looking for short passwords.\n\n\nExamples of bad and compromised passwords\nExamples of bad and compromised passwords are: Youknow123, drowssap, My2password, Qwerty12345@, StephenASmith1, Andrew24, ZaqXsw12, Johnny#12345, P@55w0rd, Jp1234567890, abdcefg, password, monkey, 123456, password, qwerty, football, baseball, welcome, abc123, 1qaz2wsx, dragon, master, monkey, letmein, login, princess, qwertyuiop, solo, passw0rd, starwars\nMost systems enforce some level of password complexity, for example: Passwords need characters from all three of the following categories: - Uppercase characters - Lowercase characters - Non-alphanumeric characters\nMost people use similar patterns (i.e. capital letter in the first position, a symbol in the last, and a number in the last 2). Password crackers know this, so they run their dictionary attacks using the common substitutions, such as “$” for “s”, “@” for “a,” “1” for “l” and so on. See the following article for password audit test.\n\n\nCounter measures\nThe counter measures that can be used to strengthen passwords are those that limit attacks to brute force attacks. Using unique passwords for each login prevents compromised passwords from being used against other sites. Using passwords that are long and complex should be used. Dictionary words, combinations of words or names should not be used. Typical word mangling, letter substitutions pre and post pending of special characters or numbers are well known techniques for obfuscating dictionary words or names and should not be used.\n\n\nOther mitigation\nMulti-factor authentication (MFA) is an additional verification step used to gain access to an online account. Typically, secret questions, codes sent to your phone or hardware tokens are used as the second factor. MFA increases security because if one credential becomes compromised, unauthorized users will be unable to meet the second authentication requirement and will not be able to access the targeted physical space, computing device, network, or database. MFA should be enabled whenever it is supported. Web pages typically ask for MFA when an attempted login is from an unrecognized device or browser."
  },
  {
    "objectID": "password_card.html#analysis-of-alternatives",
    "href": "password_card.html#analysis-of-alternatives",
    "title": "Password card",
    "section": "Analysis of alternatives",
    "text": "Analysis of alternatives\nThere are several password management schemes that are typically used. Assuming that unique passwords are being used for each login, there might be about 100 passwords that a typical user would need to keep track of. Three password management schemes are considered.\n\nPassword book: This is a handwritten password list in notebook, perhaps organized alphabetically in a binder. Use some sort of offline method and create good passwords. Keep the notebook in a secure place. Pros and cons of a computer based password manager verus a password book are discussed here. A password book can be purchased here. Backups of a password notebook can be made by photocopying (or scanning) the pages and keeping the backup in a safe deposit box. Other than banks and other financial institutions, most web sites will put a cookie on your computer and allow you to re-visit the site without re-logins.\n\nPassword card: A password card is also a paper solution, and one suitable to carry on a daily basis. A Password Card is a credit card-sized card which lets you pick very secure passwords, without having to remember them. Backups of the password card can be a photocopy which is kept in a secure location.\n\nComputer based password manager: There are various options available and this is a big topic of discussion online. Some type of password manager is appropriate for most people and might require a subscription. Computer based password manager requires a very strong master password because it protects all your other passwords.\n\nCombination of alternatives: A combination of a Password book, Password card and Computer based password manager can also be used.\n\nBasically the options are paper based and computer based. Paper based solutions are only as secure as the storage location of the password book. A password book locked in your house at home and its existence is not known is pretty secure because no one is actively looking for such a book. Needless to say, you should not be carrying around your password book in your backpack with the words “passwords” on the front of it. A password book could be used to record all your passwords of which only a few are needed on a daily basis and the password card could be used for those needed more frequently or when away from home.\nWeb based passwords managers can be hacked. For example, Lastpass reported on December 22, 2022, that a threat actor was able to copy a backup of customer vault data from the encrypted storage container. The encrypted fields remain secured with 256-bit AES encryption and can only be decrypted with a unique encryption key derived from each user’s master password. Web based password managers are not recommended for financial or email accounts, mainly for two reasons. 1) They represent an attractive target with large payoff potential. 2) It breaks the don’t put all your eggs in one basket rule.\nWhen you use a password manager like LastPass or 1Password, it stores a list containing all of the user names and passwords for the sites and apps you use, including banking, health care, email and social networking accounts. It keeps track of that list, called the vault, in its online cloud so you have easy access to your passwords from any device. LastPass said hackers had stolen copies of the list of usernames and passwords of every customer from the company’s servers.\nMost web browsers offer at least a rudimentary password manager. This is better than reusing the same password everywhere, but browser-based password managers are limited. In recent years Google has improved the password manager built into Chrome.\nComputer based password managers like Bitwarden offer a self hosted soultion in addition to the normal cloud based storage.\nCloud based password managers are targets for attack. See Bitwarden password vaults targeted in Google ads phishing attack which describes how Bitwarden and other password managers are being targeted in Google ads phishing campaigns to steal users’ password vault credentials. Most password managers are cloud-based, allowing users to access their passwords through websites and mobile apps. These passwords are stored in the cloud in “password vaults” that keep the data in an encrypted format, usually encrypted using users’ master passwords. Recent security breaches at LastPass and credential stuffing attacks at Norton have illustrated that a master password is a weak point for a password vault.\nFor this reason, threat actors have been spotted creating phishing pages that target your password vault’s login credentials, potentially authentication cookies, as once they gain access to these, they have full access to your vault. Typosquatting also called URL hijacking, a sting site, or a fake URL, is a form of cybersquatting, and possibly brandjacking which relies on mistakes such as typos made by Internet users when inputting a website address into a web browser. Should a user accidentally enter an incorrect website address, they may be led to any URL (including an alternative website owned by a cybersquatter).\nThe typosquatter’s URL will usually be one of five kinds, all similar to the victim site address:\n\nA common misspelling, or foreign language spelling, of the intended site\n\nA misspelling based on a typographical error\n\nA plural of a singular domain name\n\nA different top-level domain: (i.e. .com instead of .org)\n\nAn abuse of the Country Code Top-Level Domain (ccTLD) (.cm, .co, or .om instead of .com)\n\nOnce in the typosquatter’s site, the user may also be tricked into thinking that they are in fact in the real site, through the use of copied or similar logos, website layouts, or content.\nSpam emails sometimes make use of typosquatting URLs to trick users into visiting malicious sites that look like a given bank’s site, for instance.\nThe domain used in the ad was ‘appbitwarden.com’ and, when clicked, redirected users to the site ‘bitwardenlogin.com.’ The page at ‘bitwardenlogin.com’ was an exact replica of the legitimate Bitwarden Web Vault login page.\nUsers should always configure Multi-factor authentication in the password manager. In case credentials are inadvertently entered into a phishing site, your multi-factor authentication should prevent a total breach. Unfortunately, even with MFA protection, your accounts can still be vulnerable to advanced adversary-in-the-middle (AiTM) phishing attacks. AiTM phishing attacks are when threat actors utilize specialized toolkits like Evilginx2, Modlishka, and Muraena to create phishing landing pages that proxy to legitimate login forms at a targeted service. Using this method, visitors to the phishing page will see a legitimate service’s login form, such as Microsoft 365. When they enter their credentials and MFA verification codes, this information is also relayed to the actual site. Once a user logs in and the legitimate site sends the MFA-backed session cookie, the phishing toolkit can steal these tokens for later use.\nKeepassX is a password manager that is offline.\nA master password is required for a password manager. The master password for a password manager is similar to having just one password, since with the master password all other passwords in the vault can be obtained. The Password Manager will encrypt the user’s password vault with something like AES-256 using a key derived from the master password. But if the master password is weak, then the derived 256 bit key does not provide a AES-256 level of protection.\nA cloud based password manager requires a very strong master password, especially if all your sensitive account credentials are protected by the password manager. A 256 bit AES key derived from a process that starts with 90 equivalent bits of entropy is not 256 bits strong, but is only 90 bits strong. For example a pass phrase of four random words taken from a word list of 255,000 words, provides an equivalent password entropy of 72 bits.\n\npass_phrase_len = 4\nword_list_len = 255e3\nprint('number of passphrases: {:.3e} with {:d} words'.format(word_list_len**pass_phrase_len,pass_phrase_len))\nprint('equivalent entropy of {:.0f} bits from using {:d} words'.format(math.log2(word_list_len**pass_phrase_len),pass_phrase_len))\n\nnumber of passphrases: 4.228e+21 with 4 words\nequivalent entropy of 72 bits from using 4 words\n\n\nSuch a password could be cracked in short order.\n\nE = round(math.log2(word_list_len**pass_phrase_len))\nprint('{:,.0f} min to evaluate 1% of combinations from {:d} bits of entropy'.format(0.01*((2**E)/pw_eval_per_hour*60),E ))\nprint('which is equivalent to a password of length {:,.1f} characters'.format(solve((char_set_size**L)-2**E, L)[0].evalf()))\n\n39 min to evaluate 1% of combinations from 72 bits of entropy\nwhich is equivalent to a password of length 11.5 characters\n\n\nIf the 256 bit encryption key is derived from a short pass phrase, the effective key length is 72 bits and not 256 bits.\nIf the master password word is 16 random characters of gibberish, the equivalent key length is 101 bits.\n\n# how many characters in a jibberish password?\nnum_of_chars = 16\nchar_set_size = len('abcdefghijklmnopqrstuvwxyz'+'ABCDEFGHIJKLMNOPQRSTUVWXYZ'+'0123456789'+'!@#\\$%^&*()-+=&lt;&gt;?')\nE = round(math.log2(char_set_size**num_of_chars))\nprint('equivalent entropy of {:.0f} bits from {:d} random characters'.format(E,num_of_chars))\nprint('{:,.0f} years to evaluate 1% of combinations from {:d} bits of entropy'.format(0.01*((2**E)/pw_eval_per_hour)/24/365,E ))\n\nequivalent entropy of 101 bits from 16 random characters\n40,197 years to evaluate 1% of combinations from 101 bits of entropy\n\n\nYou need 21 random characters or 8 random words to exceed the entropy of a 128 bit key."
  },
  {
    "objectID": "password_card.html#conclusion",
    "href": "password_card.html#conclusion",
    "title": "Password card",
    "section": "Conclusion",
    "text": "Conclusion\nThe password card is secure when coupled with a 15 character long mangled passphrase. The 15 character long mangled passphrase is the only part that needs to be memorized. Using the procedure outlined, a unique and strong password can be generated for each account. The password card provides a convenient and portable way to generate and use unique passwords."
  },
  {
    "objectID": "password_card.html#revision-history",
    "href": "password_card.html#revision-history",
    "title": "Password card",
    "section": "Revision History",
    "text": "Revision History\n\n10/10/2015: Ver 1 - coding started\n\n20 Nov 2022: Python program converted to this IPython notebook"
  },
  {
    "objectID": "password_card.html#copyright",
    "href": "password_card.html#copyright",
    "title": "Password card",
    "section": "Copyright",
    "text": "Copyright\nThis work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html",
    "href": "Overshot waterwheel hydroelectric power system analysis.html",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "",
    "text": "Last update: 20 July 2022"
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#introduction",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#introduction",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Introduction",
    "text": "Introduction\nThis notebook examines the construction of a small hydroelectric system built by Michael Loftis [1], a YouTuber, real estate and insurance broker, who had a hydro system built for his off-grid cabin on 50 acres in the Ozark Mountains. The cabin and hydro system are unique and look really interesting. The cabin is available for rent as an AirBnB and is located in Thornfield, Missouri. The cabin is now advertised as having some solar panels with a gas powered generator to supplement the solar.\nMichael’s hydroelectric project looked really interesting and I was curious about the technical details. In videos [6,7], which I watched first, he discusses the status of the system. I was disappointed to hear that his system wasn’t working, because at first glance it looked very impressive. I decided to learn a little about small hydroelectric systems and document in this notebook what I’ve learned."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#scope",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#scope",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Scope",
    "text": "Scope\nThe numbers used in my calculations were estimated by me by looking at relative dimensions in the videos, so my numbers are not the actual numbers, but should be close enough to get a general idea of how the system is working. My analysis should be considered a preliminary analysis and not a detailed design review, as such, I’ve covered a few topics that were mainly of interest to me. Other than a few comments about the dam, how to build a dam is outside the scope of what I want to cover."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#description",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#description",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Description",
    "text": "Description\nThe small dam, waterwheel and generator didn’t charge Michael’s house battery system, as he had hoped it would. He posted a series of seven videos describing the effort [2, 3, 4, 5, 6, 7, 8]. The videos cover the time frame from July 2020 to April 2021. His waterwheel was constructed using wheels from an old hay rake, which belonged to his grandmother. The dam captured water from a spring on his property and he tried to generate enough electrical power to keep his five 50Ah, 24 volt Lithium batteries charged. The batteries are \\$849.00 each. In video [7] he described his gas powered generator, a PREDATOR 3500, which he runs in the morning and evening to keep his batteries charged, since the hydro is not working.\n\nThe photo above was captured from [8] and shows a side view of the dam and waterwheel. The waterwheel is operated in an overshot configuration where the wheel is rotated by water entering buckets just past the top of the wheel. You can also see the flume, which brings water from the pond to the top of the waterwheel. In this photo, the gate to the flume is closed and the hydro system is not being operated.\n\nThe photo above from [7] shows the end of the flume and the waterwheel with a large amount of splash over. Also you can see the pulley system which when connected, steps up the rotations per minute to the generator. As described in video [6], the hydro system is not working as he had hoped.\nMichael thought the flow rate from the spring during the rainy season was 500 to 1000 gallons per minute (GPM) and 300 GPM at other times [2]. In one of his videos [3] he filled a five gallon bucket in what he said was in one second, but by my estimation was closer to two seconds. This would put the flow rate at 150 GPM, but there was some spillage and the total flow wasn’t captured since he was doing this with one hand while videoing. Over the course of his videos, it appears that the flow rate is seasonal. The dam is about 4 feet tall [8] and the waterwheel has a diameter of what looks like 7 feet [5]. His generator is a 2kW permanent magnet generator, from Missouri Wind and Solar and produces 24V at 500 rotations per minute (RPM). In [5] he said the gear ratio was 8:1, but was lower initially, since two belts were shown to have been installed in subsequent videos. During a time of heavy water flow from the spring, he showed [6] the display on the Midnite Classic 200 which indicated 40 Volts at the house and 40 Watts of power from the hydro system. The power cable running to the house is 220 ft from the waterwheel.\nMy main criticisms of his hydro system are that the dam appeared not to have been built to any minimum standards and that a feasibility study was not done. Most of the work and design was performed by Jerry, his builder, a very skilled craftsman. However, I don’t think Jerry has sufficient technical training to design a small concrete dam. A basic waterwheel is conceptually simple and a workable wheel can be constructed by almost anyone who has basic tools and carpentry skills. The design of the waterwheel was constrained by the size of the antique wheels that Jerry suggested could be used as a frame for the waterwheel [5]. Michael consulted with various vendors about the generator and battery system but didn’t realize that just buying recommended items from a shopping list is not a good way to engineer a hydroelectric project. A basic feasibility study would have shown (see calculations below) that about 200 Watts of power could be generated by the waterwheel, not the 1 kW he was hoping for.\nMichael responded to many comments posted on YouTube concerning his project. He deflected all concerns about the design and construction of the dam, saying that he has complete confidence and faith in Jerry. By this point in the video series, the dam was built and holding water, so there was not a lot that could be done to address the comments about the dam, even if he was concerned, which he didn’t seem to be. He was genuinely interested in seeking suggestions about what could be done with the electrical system, but major changes to the waterwheel itself or outright replacement were off the table. The old wheels have sentimental value to him and he likes the aesthetics of the dam and waterwheel as they are now."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#bottom-line-up-front",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#bottom-line-up-front",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Bottom line up front",
    "text": "Bottom line up front\nThe summary, recommendations and conclusion are normally placed at the end of a paper; but in this notebook, I’ve moved them here to serve as an executive summary."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#summary",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#summary",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Summary",
    "text": "Summary\nThe analysis covered the following topics, which are summarized here: - Household energy requirements: the household energy requirements are TBD, but the batteries are 6,000 VAhr and this is the energy the hydro system needs to replenish each day. - Water source: spring flow rate is seasonal and a range of flow rates were used in the calculations - The dam: comments were provided concerning the dam construction and spillway - Power production vs flow and head height was calculated and determined to be about 220 Watts at 300 GPM. - Flume flow rate was calculated and found to be about 70 GPM - Waterwheel performance calculations were made and the design needs improvements - Generator, pulley system and Electrical cable were examined and the generator/pulley system needs a do over. - The electrical cable is fine."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#conclusion",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#conclusion",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Conclusion",
    "text": "Conclusion\n\nThe waterwheel is a nice idea. Seems like at 300 GPM the hydro system could charge the batteries.\nDam and pond are a nice feature on the property, but the design and construction of the dam is suspect.\nA feasibility study using some basic math and science should have been done.\n\nMichael’s system was not working for the following reasons:\n1. flume was delivering insufficient water flow, 2. waterwheel RPM was too high and the buckets could not capture or hold the water and 3. a high generator RPM needed to produce 28 to 29 absorption volts is not sustained."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#recommendations",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#recommendations",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Recommendations",
    "text": "Recommendations\n\nGet the dam evaluated, is it worth putting any additional effort into the hydro system when the dam has issues?\nseepage, foundation uplifting, inadequate spillway capacity\nremove stumps in the pond and surrounding dead trees\nGet a better estimate of seasonal flow from the spring, this will guide any decisions about upgrades to the hydro system\nFix problems with the waterwheel and flume\nResize flume and waterwheel width\nLook at alternate bucket designs with additional buckets\nConsider and evaluate other generator, gear box or pulley options\nweather proof generator and drive train\n\n\nimport pint\nureg = pint.UnitRegistry()\nimport numpy as np\nimport matplotlib.pyplot as plt"
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#units",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#units",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Units",
    "text": "Units\nIn the calculations that follow, I’m using the Python package, Pint, which allows mathematical operations with units and conversions to and from different units. Keeping track of the units will provide some error checking when performing the calculations. United States customary units are used to describe the hydro system in the narrative. All calculations are done using the International System (SI) of units.\nA list of units and conversions used by Pint is here.\n\nVariables and constants\nThere are a couple of variables and constants that will be used throughout the calculations. - Q is used for flow rate\n- tau or \\(\\tau\\) is used for torque - omega or \\(\\omega\\) is used for angular velocity - g is used to denote the gravity of Earth, standard gravity by definition is equal to 9.80665 \\(m/s^2\\) - rho or \\(\\rho\\) is used for the density of water, at 50F or 10C is 999.75 \\(kg/m^3\\) - eta or \\(\\eta\\) is used for energy conversion efficiency, accounts for the energy lost to heat\n\ng = 9.80665*ureg.meter/(ureg.sec**2) # \nrho = 999.75*ureg.kg/(ureg.meter**3) # density of water at 50F or 10C, kg/m^3"
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#electrical-energy-and-electrical-power",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#electrical-energy-and-electrical-power",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Electrical energy and electrical power",
    "text": "Electrical energy and electrical power\nElectricity generation is the process of generating electrical energy converted from other forms of energy. Electrical energy typically has units of Watt hours, which is the product of the power in watts multiplied by time in hours. Kilowatt hours is what you would commonly see on your monthly electric bill. The base units (in SI units) for electrical energy is: \\(kg \\cdot m^2 \\cdot s^{-2}\\). This is equal to the energy dissipated as heat when an electric current of one ampere passes through a resistance of one ohm for one second.\nPower is the amount of energy transferred per unit time. Electrical power typically has units of Watts. The base units (in SI units) for electrical power is: \\(kg \\cdot m^2 \\cdot s^{-3}\\). Power from electricity is the product of the current flowing through the element and of the voltage across the element. However, this gets a little complicated if the voltage and current have a phase difference, then the product of Volts x Amps is a vector product. The vector product, which can be expressed as a complex number, has units of Volt Amps and the real part of the product has units of Watts. The imaginary part is called reactive power and for this power, there is no net transfer of energy to the load. Voltage and current are usually measured with a multimeter and for alternating current (AC) measurements, the RMS values are usually measured. The product of the RMS voltage and the RMS current is called the apparent power, which has units of Watts. It’s almost always the apparent power that we are talking about when we talk about the Watts needed for the household.\nI’ll do my best not to mix up the usage of power and energy."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#household-energy-requirements",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#household-energy-requirements",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Household energy requirements",
    "text": "Household energy requirements\nThe energy requirements for Michael’s off grid cabin should have been the first topic to consider. Michael’s power requirements can be estimated from the battery and gas generator system he currently is using. The average household in Missouri uses 1,086 kWh Per Month according to this report and this web page. This is 36,200 Whr per day.\nMichael’s batteries are connected in parallel. So the total nominal battery voltage is 24 volts and the total current is the sum of the currents available from the batteries.\n\nbattery_voltage = 24*ureg.volts\nprint('battery voltage: {:s}'.format(f\"{battery_voltage:.0f~P}\"))\n\nnumber_of_batteries = 5\nbattery_rating = 50*ureg.amps*ureg.hours\nhouse_battery_capacity = number_of_batteries*battery_rating\nprint('house battery capacity: {:s}'.format(f\"{house_battery_capacity:.0f~P}\"))\nprint('house battery energy: {:s}'.format(f\"{battery_voltage*house_battery_capacity:,.0f~P}\"))\n\nbattery voltage: 24 V\nhouse battery capacity: 250 A·hr\nhouse battery energy: 6,000 A·V·hr\n\n\nThe batteries supply energy to the house during times when the generator is not running. The available battery energy for the house, in \\(volt \\cdot amp \\cdot hours\\), is the product of the nominal battery voltage and the rated capacity. For resistive loads, \\(volt \\cdot amp \\cdot hours\\) can be considered equivalent to Watt hours.\nSince hydro is not working, a gas powered generator, the Predator 3500, is used during the day to charge the batteries. The Predator 3500 has a maximum running watts of 3,000. Michael says he runs the generator about 10 hours per day (a few hours in the morning and then from dinner time until 10pm), the energy generated by the Predator 3500 is calculated below.\nPhotos on the AirBnB web page for the cabin show a photovoltaic installation of what looks like 20 panels. The solar panels probably are between 100 and 200 Watts each for a total of 2000 to 4000 Watts of solar power for the array. Solar is not included in this analysis.\n\n# generator is running 10 hours per day and rated to produce 3000 watts continuously\ngenerator_run_time = 10*ureg.hour\ngenerator_rating = 3000*ureg.watts\ngenerator_energy = generator_run_time*generator_rating\nprint('generator energy: {:s} per day'.format(f\"{generator_energy:,.0f~P}\"))\n\ngenerator energy: 30,000 W·hr per day\n\n\nThe generator produces 30,000 Whr and the fully charged batteries contain 6,000 VAhr. The amount of energy produced by the generator is the amount the family consumes. We can assume that the hydro system will run continuously whereas the gas powered generator is run for ten hours each day.\n\nBut…\n30,000 Whr per day seems really high, so I would question his generator run time per day. Or maybe my math is wrong.\nSetting aside his generator usage, he intended that the hydro system was going to charge his batteries. So, let’s assume that his daily energy needs can be satisfied from his batteries. His batteries hold energy of 6,000 VAhr (taking a short cut and equating Volt Amps to Watts); and 6,000 Whr per day for a very energy efficient family is doable. It follows that he needs about 6,000 Whr per day of hydro energy to match his installed batteries.\n\nprint('hydro energy needed per day: {:s}'.format(f\"{6000*ureg.watt*ureg.hour:,.1f~P}\"))\n\nhydro energy needed per day: 6,000.0 W·hr\n\n\nOver a 24 hour period, the power he needs from the hydro system is:\n\nprint('power needed from hydro generator: {:s}'.format(f\"{(6000*ureg.watt*ureg.hour)/(24*ureg.hour):,.1f~P}\"))\n\npower needed from hydro generator: 250.0 W"
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#battery-charging",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#battery-charging",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Battery charging",
    "text": "Battery charging\nThe batteries are 50Ah 24V LiFePO4 Deep Cycle batteries from Battle Born Batteries with a price tag of \\$849 each. They have an absorption voltage of 28.4V to 29.2V and the recommended charge rate is 50% of the battery or battery bank capacity or less. The absorption time is 15 minutes per 50Ah of capacity at a charging current of 25A per battery. Other specifications: - Float: 26.8V to 27.6V - Battery Charge Temperature Range: 25°F (-3°C) to 135°F (57.2°C) - Battery Discharge Temperature Range: -4°F (-20°C) to 135°F (57.2°C) - Cell Charge Temperature: 32°F (0°C) to 131°F (55°C) - Cell Discharge Temperature: 68°F (20°C) to 140°F (60°C)\nMichael has his batteries connected in parallel, so the current is the sum of the currents that each battery can produce. The hydro generator power curves are shown later, but for now let’s assume that the generator can produce 30 volts at 20 amps. The charging time is calculated below.\n\nbattery_charge_rate = house_battery_capacity/2\nprint('Max allowable battery charge rate: {:s}'.format(f\"{battery_charge_rate:,.1f~P}\"))\n\ngenerator_amps = 20*ureg.amp\nprint('generator charge current: {:s}'.format(f\"{generator_amps:,.1f~P}\"))\nprint('battery charge time: {:s}'.format(f\"{(battery_charge_rate/generator_amps).to('hour'):,.1f~P}\"))\n\nMax allowable battery charge rate: 125.0 A·hr\ngenerator charge current: 20.0 A\nbattery charge time: 6.2 hr\n\n\nIf the hydro system can produce enough energy to charge his batteries in 6 hours, the power produced during the remaining hours could be used to power other items in the house and in the winter keep his batteries from getting too cold.\nPlot battery charge time versus charging current.\n\ncharging_current = np.arange(2,25,0.5)*ureg.amp\n\nplt.plot(charging_current.to('amp'),(battery_charge_rate/charging_current).to('hour'))\n\nplt.grid()\nplt.xlim((1,25))                                          \nplt.ylabel('Charging time, hours')\nplt.xlabel('Charging current, amp')\n\nplt.title('Estimated battery charging time')\nplt.show()\n\n\n\n\n\n\n\n\nThe plot above shows that for charging currents of less than about 5.2 amps, the hydro generator can’t fully charge his batteries from the empty condition within one 24 hour period. Most likely the family is using battery energy while charging the batteries, so the hydro generator would need to produce about 8.3 amps."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#site-plan",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#site-plan",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Site plan",
    "text": "Site plan\nIn Michael’s videos about the hydro project, I got the impression that he did not have any measured elevation data for his property. He thought he had about 30 feet of elevation from the spring to his property line. This might be enough for a penstock and tail pipe driving a Pelton or inline turbine. For Michael’s waterwheel the head height is approximately the diameter of the waterwheel but, depending on the bucket design and release angle, could be a little less."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#water-source",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#water-source",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Water source",
    "text": "Water source\nThe water source for the dam comes from a spring located a short distance away from the cabin. The spring also provides water to the cabin’s holding tank for household use. While watching Michael’s videos, I did not hear that he has documented historical data for the water flow rate. Historical data is critical for determining the economic viability of the hydro project. Michael indicated that from February to June, there is lots of water flowing from the spring. Over the course of the video series, he commented how the spring wasn’t running like it was while they were building the dam. Since the flow rate seems to be seasonal, the analysis that follows will consider a range of flow rates and not use just one value.\nOne thing to note is that in [8], the water out of the spring was muddy, which could mean that a lot of surface water flows down the hill during periods of heavy rain and is mixing with the spring water. Surface water mixing in with the spring water could compromise the safety of the spring as a source of potable water."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#the-dam",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#the-dam",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "The dam",
    "text": "The dam\nThe purpose of the dam is to capture water from the spring and allow for the flume to sit at the correct height relative to the waterwheel. The dam’s reservoir is an attractive feature for the property and should be a source of enjoyment year around. He said the water was cold (50F), so in the warm summer months it should be refreshing. The dam structure is a concrete retaining wall, with a water depth of about 4.5 feet at the wall. This type of dam can be classified as a concrete gravity dam where the weight of the dam itself keeps it in place against the weight of the water. Videos [2,3] show some of the dam construction and the following observations and comments are provided:\n- The dam’s foundation did not appear to be adequately prepared. Concrete gravity dams are suitable for sites where there is a reasonably sound rock foundation, although a low dam can be built on other soil types. Michael said in the video that Jerry dug down to rock, but this was not apparent. Settling of the foundation and expansion from freezing water from seepage can lead to weakening of the foundation and wall. - The reservoir evacuation method of using a plug in the pipe could have been better thought out. An important consideration is the ability to evacuate (lower or drain) the reservoir in a timely manner. - Interrupting the pour between the footing and the wall created a cold joint, a possible source of leaks. - There was a conspicuous paucity of rebar visible in the construction videos. - The spillway is insufficient. - Head race and flume did not line up with the waterwheel.\nThere were questions in the comment section about the permit for the dam construction. Michael said he didn’t need a permit. I did a little bit of searching on the internet and he seems to be correct. If the water impounded has a surface area of less than fifteen acres, or the height of the dam is less than 35 feet, and is not on a navigable waterway, a permit is not required.\nA small spillway was incorporated into the dam in the center section. The spillway is a hydraulic structure that passes normal (operational) and/or flood flows in a manner that protects the structural integrity of the dam. The spillway appears to be sized incorrectly as evidenced by the dam being over topped in [8].\nThe spillway width is estimated to be 4 feet wide and the depth of the spillway looks like about 3 inches.\n\nspillway_width = 4*ureg.feet # 4 ft\nspillway_water_head = 3*ureg.inch # 3 inches\n\nThe rectangular weir formula is used to calculate the flow through the spillway.\n\\(Q= \\frac {2}{3} \\times C_d \\times (2g)^{1/2} \\times L \\times H^{3/2}\\)\nWhere:\nQ = the total discharge\n\\(C_d\\) = discharge coefficient\ng = acceleration due to gravity\nL = the effective crest length\nH = the total hydraulic head above the spillway\nReference sources for the weir formula are here, here and here.\n\nL = spillway_width.to('meter')\nH = spillway_water_head.to('meter')\nCd = 0.5 # discharge coefficient, a nominal value was chosen, typical values range from 0.4 to 0.6 and depends on a lot of factors.\n\n# need to remove units for calculation, then set units back to m^3/sec\nQ_spillway = ((2/3)*Cd*L.magnitude*2*(g.magnitude)**(1/2)*(H.magnitude)**(3/2))*ureg.meter**3/ureg.sec\nprint('spillway flow rate: {:s}'.format(f\"{Q_spillway.to('gal/min'):.1f~P}\"))\n\nspillway flow rate: 848.6 gal/min\n\n\nThe current spillway can accommodate about 850 GPM, but it should be increased by several inches in head height to accommodate 2000 GPM or more depending on the results of a hydrology study for the local drainage into the reservoir.\n\nUsing the weir formula to estimate flow rate\nThe wier formula can be used to estimate the water flow. In videos [6,7] there looks to be about a half inch deep of water flow through the spillway.\n\nspillway_water_head = 0.5*ureg.inch\n\nL = spillway_width.to('meter')\nH = spillway_water_head.to('meter')\nCd = 0.5 # discharge coefficient, a nominal value was chosen, typical values range from 0.4 to 0.6 and depends on a lot of factors.\n\n# need to remove units for calculation, then set units back to m^3/sec\nQ_spillway = ((2/3)*Cd*L.magnitude*2*(g.magnitude)**(1/2)*(H.magnitude)**(3/2))*ureg.meter**3/ureg.sec\nprint('low season flow rate: {:s}'.format(f\"{Q_spillway.to('gal/min'):.1f~P}\"))\n\nlow season flow rate: 57.7 gal/min\n\n\nTrying to estimate the flow rate from Michael’s videos is admittedly very inaccurate, however it’s the best we can do to substantiate Michael’s claims of 500 to 1000 gallons per minute (GPM) and 300 GPM at other times. Based on the weir calculation using 1/2 inch depth of flow, the flow rate is nowhere near what Michael claims it is during the low season."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#gravitational-power-of-water",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#gravitational-power-of-water",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Gravitational power of water",
    "text": "Gravitational power of water\nThe harvesting of the gravitational energy of water is a proven source of energy. Since a waterwheel is used to extract power from the water, the head height is approximately the diameter of the waterwheel. Water enters at the top of the wheel and the weight of the water causes the wheel to rotate until a point near the bottom of the wheel. So let’s use the diameter of the waterwheel. For the flow rate, we can use a value of 300 GPM since this is what Michael said was the flow rate in [2].\nThe gravitational power of water is given by:\n\\(P = \\rho \\times g \\times Q \\times H\\)\nwhere:\nP = gravitational power of water\nH = height of fall\nQ = flow rate\ng = acceleration due to gravity\n\\(\\rho\\) = density of water\nThe gravitation power of water is easily calculated and Michael should have run his numbers through this formula first thing. However, if he did the math and was overly optimistic about the efficiency of his waterwheel, he could have been deceived. If he looked at a range of efficiencies, he would have seen that things didn’t look so good at the lower end, which could have told him that an in depth and thorough preliminary design was needed. Reference sources for the hydroelectric power equation are here and here.\n\nhead_height = 7*ureg.feet # the estimated diameter of the waterwheel\nprint('head height: {:s}'.format(f\"{head_height:.1f~P}\"))\n# convert to meters and save value in variable H for use in calculations\nH = head_height.to_base_units()\nprint('head height in base units: {:s}'.format(f\"{H:.4f~P}\"))\n\nflow_rate = 300*ureg.gal/(1*ureg.min)\nprint('flow rate: {:s}'.format(f\"{flow_rate:.1f~P}\"))\nQ = flow_rate.to_base_units()\nprint('flow rate in base units: {:s}'.format(f\"{Q:.4f~P}\"))\n\nhead height: 7.0 ft\nhead height in base units: 2.1336 m\nflow rate: 300.0 gal/min\nflow rate in base units: 0.0189 m³/s\n\n\nThe maximum efficiency of overshot waterwheels is listed in [11] as being between 80 and 85% maximum, which is for an optimized design. Michael’s waterwheel has a number of issues, the most serious is the substantial amount of water splashing out of the bucket. So Michael’s waterwheel probably has an efficiency of around 60%. The efficiencies for the generator and charge controller were estimated from literature and catalogs. The efficiency for the generator is reduced to 95% to account for the low operating RPM compared to the rated RPM. The charge controller is assumed to be relatively efficient so a 97% value is used. - \\(\\eta\\) for waterwheel = 60% - \\(\\eta\\) for generator = 95%\n- \\(\\eta\\) for charge controller = 97%\n\n# Gravitational power of water\ngrav_pwr_of_water = (rho*g*Q*H) #.to_base_units().to('watt')\nprint('gravitational power of water: {:s}'.format(f\"{grav_pwr_of_water.to('watt'):.2f~P}\"))\n\neta_waterwheel = 0.6 # for a small waterwheel\neta_generator = 0.95\neta_charge_controller = 0.97\neta_total = eta_waterwheel*eta_generator*eta_charge_controller\nest_pwr = grav_pwr_of_water*eta_total\nprint('electrical power with efficiency factors: {:s}'.format(f\"{est_pwr.to('watt'):.1f~P}\"))\n\ngravitational power of water: 395.92 W\nelectrical power with efficiency factors: 218.9 W\n\n\nThe calculations above provide an indication of the power the hydro system is capable of producing. The estimated electrical power is about 219 watts. If the efficiency of the waterwheel could be improved to 0.7, then about 260 Watts could be generated, which might be sufficient to charge the batteries.\nThe calculations show that the expected power production is rather low and the ability to charge the house batteries is doubtful. Before proceeding with the project, one would need to look at other options. It sounded like Michael really wanted a dam and waterwheel, this being the case, a larger wheel diameter should have been considered in light of these calculations. Michael could have still used the old wheels, and Jerry could have built a larger outer frame to extend the radius. Also, the waterwheel is somewhat narrow compared to similar historical waterwheels, so Jerry could have increased the width."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#estimated-power-production-vs-flow-and-height",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#estimated-power-production-vs-flow-and-height",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Estimated power production vs flow and height",
    "text": "Estimated power production vs flow and height\nThe plot below shows the estimated production of electrical power for a range of flow rates and water head heights (in this case set by the diameter of the waterwheel). Mechanical and electrical efficiencies discussed above are included. The range of flow rates from the spring were talked about in the videos. In the plot below, I have flow rates ranging from 100 to 500 GPM and head height set by waterwheel diameters of 6, 7 and 8 feet.\n\nflow_rate = np.linspace(50,500,10)*ureg.gal/ureg.min # flow rate range in gallons per minute\nhead_height = np.array([6,7,8])*ureg.feet # head height, range in feet\n# convert to metric\nQ = flow_rate.to_base_units()\nH = head_height.to_base_units()\n\nfor i in range(len(head_height)):\n    plt.plot(flow_rate.to('gal/min'),(rho*g*Q*H[i]*eta_total).to('watt'),\n        label = 'water head: {:s}'.format(f\"{H[i].to('feet'):.0f~P}\"))\n\nplt.legend(bbox_to_anchor=(1.4, 1))\nplt.grid()\n\nplt.ylim((0,600))\nplt.xlim((100,500))                                          \nplt.ylabel('electrical power, W')\nplt.xlabel('water flow rate, GPM')\n\nplt.title('Estimated production of hydro power')\nplt.show()\n\n\n\n\n\n\n\n\nThe chart above clarifies that for small flow rates of less than 300 GPM and small diameter wheels, the possible power output is not sufficient to supply the household using the efficiencies discussed above. Families that conserve their use of electrical power need about 10 kWhr per day (or less, but definitely a lot more if air conditioning is used)."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#the-flume",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#the-flume",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "The flume",
    "text": "The flume\nThe flume carries water from the dam to the top of the waterwheel. By examining the videos, I made some estimates for the flume dimensions. The width of the flume was about the same width of the waterwheel, which makes sense, since you want a nice flow of water into the buckets. The side walls of the flume looked like 2 by 6 inch boards. Looking at [7] when Michael opens the gate, the depth of the water in the channel looks like 1.5 to 2 inches of flow.\nI can use the Manning equation for open channel flow to calculate the flow rate in the flume. Mannings equation is an empirical equation that applies to uniform flow in open channels and is a function of the channel velocity, flow area and channel slope.\n\\(V = \\frac {s^{1/2} \\times R^{2/3}} {n}\\)\nwhere:\nV - water velocity\nn - Manning’s roughness coefficient; unplaned wood = 0.013, wood sides and smooth sheet metal bottom\nR - The channel’s hydraulic radius, calculated by dividing the water flow’s cross-sectional area A by its wetted perimeter P\ns - Slope of the channel’s bottom surface\nExamining Manning’s equation, we can see that the area and slope are directly proportional to the water flow rate, which means an increase in area and slope would increase the water flow rate. On the other hand, the roughness coefficient and the wetted perimeter are inversely proportional to the water flow rate, meaning that increasing their values would decrease the water flow rate.\nThe slope of the flume was not apparent in any of the videos, so I’m using a value of 0.01.\n\nflume_width = 10*ureg.inch  # 10 inches\nwater_depth = 2*ureg.inch # 2 inches\n# convert to metric\nflume_width.ito('meter')\nwater_depth.ito('meter')\nwater_cross_section_area = water_depth*flume_width\nprint('water_cross_section_area = {:s}'.format(f\"{water_cross_section_area:.4f~P}\"))\nwetted_perimeter = 2*water_depth+flume_width\nprint('wetted_perimeter = {:s}'.format(f\"{wetted_perimeter:.4f~P}\"))\nhydraulic_radius = water_cross_section_area/wetted_perimeter\nprint('hydraulic_radius = {:s}'.format(f\"{hydraulic_radius:.4f~P}\"))\nroughness_coefficient = 0.01 # wood sides and smooth sheet metal bottom\nslope = 0.1/100 # slope of the flume\n\n# need to use magnitude of quantity when using fractional exponents\nwater_flume_velocity = (((hydraulic_radius.magnitude)**(2/3)*slope**(1/2))/roughness_coefficient)*ureg.meter/ureg.sec\n\nprint('water_flume_velocity = {:s}'.format(f\"{water_flume_velocity:.4f~P}\"))\nvolumetric_flow_rate = water_flume_velocity*water_cross_section_area\nprint('volumetric_flow_rate = {:s}'.format(f\"{volumetric_flow_rate:.6f~P}\"))\nprint('volumetric_flow_rate = {:s}'.format(f\"{volumetric_flow_rate.to('gal/min'):.2f~P}\"))\n\nwater_cross_section_area = 0.0129 m²\nwetted_perimeter = 0.3556 m\nhydraulic_radius = 0.0363 m\nwater_flume_velocity = 0.3466 m/s\nvolumetric_flow_rate = 0.004472 m³/s\nvolumetric_flow_rate = 70.89 gal/min\n\n\nManning’s equation tells us that about 70 GPM are delivered by the flume to the waterwheel, so we can conclude that the flume is not sized correctly and several more inches of flow depth and/or slope are needed. The Manning formula has accuracies of \\(\\pm \\text{10 to 20%}\\). Reference sources for the Manning’s equation formula are here, here and here.\nPlot flume flow rate over range of slopes and depths.\n\nwater_depth = np.linspace(0.1,6,10)*0.0254 # water depth in flume, in inches, then converted to meters\n\nflume_length = 12*12 # feet converted to inches\nflume_drop = np.array([0.5,2,4,6,8,12,18]) # total drop at far end of flume in inches\nslope = (flume_drop/flume_length)/100 # flume slope, percent\n\nfor i in range(len(slope)):\n    plt.plot(water_depth/0.0254,(((water_depth*flume_width)/(2*water_depth+flume_width))**(2/3)*slope[i]**(1/2))/roughness_coefficient*(water_depth*flume_width)*60/0.003785,\n        label = 'slope: {:.2f}%'.format(slope[i]*100))\n\nplt.legend(bbox_to_anchor=(1.1, 1))\nplt.grid()\n\n#plt.ylim((0,1))\nplt.ylabel('Q, gpm')\nplt.xlabel('flume water depth, inches')\n\nplt.title('range of flume flows vs. depth and slope')\nplt.show()\n\n\n\n\n\n\n\n\nAs we can see in the plot above, in order for the flume to deliver up to 300 GPM, modifications to the flume are required. The calculations above were done with the flume width set to 10 inches, which is the estimated width of the waterwheel. But to get 300 GPM in this channel would mean that water velocity is going to be too high for the operation of the wheel. I think the flume and waterwheel width are serious flaws in the current design that can’t be overcome by tweaks elsewhere in the system."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#flume-to-waterwheel-interface",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#flume-to-waterwheel-interface",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Flume to waterwheel interface",
    "text": "Flume to waterwheel interface\nThe level of the flume at the water exit point should be very near the top center of the waterwheel. Depending on the velocity of the water there is some amount of horizontal throw and the exact position and the corresponding angle of the entry to the wheel probably is best optimized by trial and error. One thing to note is that historical waterwheels seem to be much wider than Michael’s wheel and the water velocity in the flume is lower."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#the-waterwheel",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#the-waterwheel",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "The waterwheel",
    "text": "The waterwheel\nWaterwheels have a long history and they were a driving force behind the earliest stages of industrialization in Britain. John Smeaton’s scientific investigation of the water wheel led to significant increases in efficiency supplying much needed power for the Industrial Revolution. A historical overview of waterwheels in given in [11] along with a list of overshot waterwheels in current operation which are generating electrical power. Most of these operate with much higher flow rates, on average 6,000 gal/min, which is substantially greater than what Michael has available. The waterwheel operating with the smallest flow rate at 1268 gal/min, is a 13 foot diameter, 2.4 foot wide wheel, with 36 buckets turning at 8 RPM and generating 2.2kW of electrical power. This waterwheel is operated by PI Mitterfellner GMBH, located in Austria.\nMichael’s water wheel was built by Jerry and Michael posted a slide show of the construction in [10]. From an Aesthetic point of view, the waterwheel is very nice. The dimensions of the waterwheel were estimated from the videos and compared to the relative heights of Jerry and Michael’s Dad when they were off loading the wheel. The geometry of the water chamber or bucket was not shown in any detail. In the photo below, it looks like the paddles of the water chamber have a small radial section that connects to a longer board at an angle. The angle of the longer board doesn’t look correct, it needs more tilt.\n\nThe outer radius looks to be about 3.5 feet. The inner radius is about 3 feet. The bucket width looks to be approximately 10 inches wide. The number of buckets appears to be 12. The angles appear such that most of the water will exit the wheel at about 90 degrees measured from top center. Overshot waterwheels are relatively efficient mechanically and are easily maintained. The overshot waterwheel is a slow speed device and usually designed to operate between 5 and 15 RPM. This limits its usefulness as a power source for the generation of electricity because gearbox or pulleys are needed to step up the rotational speed.\nThe diagram below shows the components of the overshot waterwheel. The weight of the water on the downstream chambers causes a torque on the wheel making it rotate.\n\nDiagram of an overshot waterwheel by Malcolm Boura obtained from Wikipedia.\nHistorical waterwheels have a lot more buckets than Michael’s waterwheel. In the diagram above, the paddles that separate the water chambers are at an angle. Depending on the design, the angels vary between 20 and 30 degrees. Some waterwheel designs have a small flat section or have chambers with the scoops optimized to hold the water through a larger range of angles as the wheel rotates.\nThere is a large collection of waterwheels on YouTube. The Egloffstein Franconia waterwheel is connected to a 12kW generator and the Dalby Waterwheel was one of the first hydroelectric plants on the Hood Canal in WA, built in 1923.\nWe can do some simple calculations to estimate the volume of the buckets.\n\nnum_buckets = 12 # number of buckets on the waterwheel\nbucket_width = 10*ureg.inch\nouter_radius = 3.5*ureg.feet\ninner_radius = 3*ureg.feet\n\n# convert dimensions to meters\nbucket_width.ito('meter')\nouter_radius.ito('meter')\ninner_radius.ito('meter')\n\nbucket_vol = (np.pi*outer_radius**2 - np.pi*inner_radius**2)*bucket_width/num_buckets\nprint('bucket volume: {:s}'.format(f\"{bucket_vol.to('gallons'):.2f~P}\") )\n                                    \n# calculate chamber arc, \nbucket_arc = (360/num_buckets)*ureg.degree\nbucket_arc.ito('radian')                                    \nprint('bucket arc: {:s}'.format(f\"{bucket_arc.to('degree'):.1f~P}\") )\n\nbucket volume: 5.30 gal\nbucket arc: 30.0 deg"
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#bucket-fill-level-vs-rpm-for-various-flow-rates",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#bucket-fill-level-vs-rpm-for-various-flow-rates",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Bucket fill level vs RPM for various flow rates",
    "text": "Bucket fill level vs RPM for various flow rates\nThe number of buckets in the waterwheel is low compared to historical waterwheels. The following plot looks at bucket fill percentage versus waterwheel RPM at various flow rates.\n\nflow_rate = np.array([50,100,150,200,300])*ureg.gal/ureg.min # flow rate range in gallons per minute\n# convert to metric\nQ = flow_rate.to_base_units()\n\nwheel_revs_per_sec = np.linspace(2,10,100)*ureg.rpm\nomega = wheel_revs_per_sec.to_base_units()\n\nbucket_arc = (np.pi/num_buckets)*ureg.radian\n\nfor i in range(len(Q)):\n    plt.plot(omega.to('rpm'),((Q[i]*(bucket_arc/omega))/bucket_vol).magnitude*100,label = 'Q={:s}'.format(f\"{Q[i].to('gal/min'):.0f~P}\"))\n\nplt.legend(bbox_to_anchor=(1.5, 1))\nplt.grid()\n\n#plt.ylim((0,10))\nplt.ylabel('bucket % full')\nplt.xlabel('waterwheel RPM')\n\nplt.title('title')\nplt.show()\n\n\n\n\n\n\n\n\nThe calculations show that the buckets are not being filled to even 50% for RPM’s greater than 5. More buckets are needed to better utilize the range of flow rates expected. The pulley 8:1 system that Michael is using has the waterwheel rotating at 62 RPM, where only about 2% of the bucket capacity will be used at a flow rate of 300 gal/min."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#maximum-rotational-speed",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#maximum-rotational-speed",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Maximum rotational speed",
    "text": "Maximum rotational speed\nThe rotational speed of the waterwheel is limited by the centrifugal force acting on the water in the buckets. The centrifugal force is directed radially outwards from the waterwheel and if the rotational speed is sufficiently high, the water will be flung out of the buckets, since gravity acting towards the center of the earth can’t keep the water contained.\nThe centrifugal force can be calculated as follows:\n\\(F=m \\times \\omega ^{2} \\times r\\)\nwhere:\nF = the centrifugal force\nm = the mass of the object, in this case a unit mass of water\nr = the radius of rotation\n\\(\\omega\\) = the angular velocity\nThe plot below shows the force on a unit mass of water due to gravity compared to the centrifugal force versus rotational speed.\n\navg_water_radius = (outer_radius + inner_radius)/2\nwheel_revs_per_sec = np.linspace(2,40,10)*ureg.rpm\nomega = wheel_revs_per_sec.to_base_units()\n\nm = 1*ureg.kg\nr = avg_water_radius\nffg = np.ones(len(omega))*(m*g)\n\nplt.plot(omega.to('rpm'),ffg.to('force_pound'),label='force from gravity')\nplt.plot(omega.to('rpm'),(m*r*omega**2).to('force_pound'),label='force from rotation')\n\nplt.legend(bbox_to_anchor=(1.5, 1))\nplt.grid()\n\n#plt.ylim((0,10))\nplt.ylabel('force, lbs')\nplt.xlabel('waterwheel rpm')\n\nplt.title('Force of gravity and centrifugal force')\nplt.show()\n\n\n\n\n\n\n\n\nIn order to keep the water in the buckets, the rotational speed of the waterwheel should be kept to about 10 RPM. Later in this notebook, the pulley system and generator is analyzed. Michael thought he needed 500 RPM on the generator shaft and 62 RPM on the waterwheel. At this RPM there is a large centrifugal force on the water in the buckets and much of the water would be flung out."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#run-test",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#run-test",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Run test",
    "text": "Run test\nTwo frames were captured from [6] and combined into the image below. On the left is the waterwheel running with the pulleys connected to the generator and on the right is the display of the Midnite charge controller, which is indicating that the input is 40.3 volts at 40 Watts. There is a large amount of splash over, indicating not all of the water is being captured.\n\nI’m not familiar with the operation of the charge controller, so I can’t comment on what’s being shown on the display. Michael did say that his batteries were not being charged under this condition.\nLooking at the photo on the left, I would say that there are three things happening. The paddles are slapping the flow of water coming off the flume, the stream is misaligned and water is being flung out of the buckets. Clearly, some adjustments are needed. The waterwheel is running somewhat as a turbine, where the wheel is rotated by both the velocity of the flow and of the weight of the water in the buckets.\nThe flume water velocity and flow rate were calculated above:\n\nprint('water_flume_velocity = {:s}'.format(f\"{water_flume_velocity:.4f~P}\"))\nprint('volumetric_flow_rate = {:s}'.format(f\"{volumetric_flow_rate:.6f~P}\"))\n\nwater_flume_velocity = 0.3466 m/s\nvolumetric_flow_rate = 0.004472 m³/s\n\n\n\nV = water_flume_velocity\nQ = volumetric_flow_rate\n\nThe power from the velocity of the water in the flume is calculated below:\n\nprint('power in the water flow from the flume: {:s}'.format(f\"{(0.5*(rho*Q)*V**2).to('watt'):.2f~P}\"))\n\npower in the water flow from the flume: 0.27 W\n\n\nThere doesn’t appear to be much water captured by the buckets and some of it looks like it’s being flung out. So let’s say half of the flow is captured and drops a height of 2 feet before being forced out by centrifugal force. The power from gravity of the water in the bucket is:\n\nH = 2*ureg.foot\nQ = volumetric_flow_rate/2\nprint('power from gravity of water: {:s}'.format(f\"{(g*rho*Q*H).to('watt'):.2f~P}\"))\n\npower from gravity of water: 13.36 W\n\n\nTaking both of these together, it’s clear that not much power is being generated by the waterwheel when operated this way.\nIf I were to speculate as to why the charge controller is reading 40 Watts on the display, I would say the charge controller is hunting for the maximum power point and momentarily seeing a bit of energy stored in the rotational inertia of the wheel. When the electrical load is reduced and the wheel is allowed to spin faster, the charge controller sees the voltage rise and applies some load. When the load is applied, the wheel slows down and the voltage drops along with the power. The charge controller reduces the load and this oscillation continues. I don’t know where in this cycle the displayed power is read."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#generator-and-pulley-system",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#generator-and-pulley-system",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Generator and pulley system",
    "text": "Generator and pulley system\nThe generator used in this hydro system is a 2000 Watt Freedom II Hydro PMG Permanent Magnet Generator from Missouri Wind And Solar, with a price tag of \\$969. This generator has a 28 magnet dual rotor and there are two stator windings. So it’s actually two generators on the same shaft. There are two, three phase outputs from the generator (6 wires total) and two rectifier blocks are used in Michael’s system. Six conductors were used to bring the power from the generator to the house. It was not clear in any of the videos if Michael had the output of the rectifier blocks wired in series or parallel (I think a series connection would be the proper connection as the input to the charge controller). According to Missouri Wind And Solar, the generator will produce 12 volts at 266 RPM, 24 volts at 500 RPM and 48 volts at 900 RPM. A specification sheet for the generator is not available, but Missouri Wind And Solar provided answers to my questions via emails. The voltages versus RPM are voltages under load and the maximum power of 2000 Watts is produced between 1400 and 1500 RPM.\nThe plot below shows the under load voltage versus RPM, with an extrapolated data point at 1500 RPM of 80 volts and 2000 Watts. The calculations that follow assume that the generator can be made to run at 500 RPM. I don’t think this is possible, since the calculations above show the waterwheel is generating about 220 Watts of power and the flow rate in the flume is insufficient at only 70 GPM. I think the generator needs a closer look since it’s being operated at about 30% of the advertized full power speed. The Njorgen 105/34, for example, is a better choice for a waterwheel. The Njorgen 105/34 will produce 5kW at 400 Volts with 150 RPM, according to the datasheet. DIY’ers are making axial flux alternators for windmills and a tech savvy maker could design and construct a generator optimized for the low RPM of a waterwheel (an idea for a future Jupyter notebook).\n\ngen_volts = np.array([12,24,48])\ngen_rpm = np.array([226,500,900])\n\ny = gen_volts\nx = gen_rpm\nm, c = np.polyfit(x, y, 1)\nprint('generator voltage vs rpm slope: {:.2f}'.format(m))\nprint('generator voltage vs rpm intercept: {:.2f}'.format(c))\n\ngen_rpm_plt = np.linspace(200, 1500, 10)\nplt.plot(gen_rpm,gen_volts,'ok',label = 'data points provided by the vendor')\nplt.plot(gen_rpm_plt,m*gen_rpm_plt + c, '-b',label='least squares fit')\nplt.plot(1500,80,'or',label = '2000 Watts at 1500 RPM')\n\nplt.legend(bbox_to_anchor=(1.7, 1))\nplt.grid()\n\nplt.ylim((0,100))\nplt.ylabel('generator voltage, under load')\nplt.xlabel('RPM')\n\nplt.title('Generator voltage vs RPM')\nplt.show()\n\ngenerator voltage vs rpm slope: 0.05\ngenerator voltage vs rpm intercept: -1.21\n\n\n\n\n\n\n\n\n\nThe plot below is the estimated generator power as a function of RPM assuming power is linear with RPM and including a derating factor at lower RPM.\n\ngen_eff_high = 1.0 # derating value at high end of RPM range\ngen_eff_low = 0.7 # derating value at low end of RPM range\n\n# generate power derating vs RPM\nm1, c1 = np.polyfit([226,1500], [gen_eff_low,gen_eff_high], 1) # range of RPMs and derating\n\ngen_pwr = np.array([2000*226/1500,2000])\ngen_rpm = np.array([226,1500])\n\ny = gen_pwr\nx = gen_rpm\nm2, c2 = np.polyfit(x, y, 1)\n\ngen_rpm_plt = np.linspace(226, 1500, 10)\nplt.plot(gen_rpm_plt,(m1*gen_rpm_plt + c1)*(m2*gen_rpm_plt + c2), '-',label='generator pwr w/ rpm derating')\n\nplt.plot(1500,2000,'or',label = '2000 Watts at 1500 RPM')\nplt.plot(900,(m1*900 + c1)*(m2*900 + c2),'^',label = '{:.0f} Watts at 900 RPM'.format((m1*900 + c1)*(m2*900 + c2)))\nplt.plot(500,(m1*500 + c1)*(m2*500 + c2),'^',label = '{:.0f} Watts at 500 RPM'.format((m1*500 + c1)*(m2*500 + c2)))\nplt.plot(226,(m1*226 + c1)*(m2*226 + c2),'^',label = '{:.0f} Watts at 226 RPM'.format((m1*226 + c1)*(m2*226 + c2)))\n\nplt.legend(bbox_to_anchor=(1.7, 1))\nplt.grid()\n\n#plt.xlim((0,1600))\n#plt.ylim((0,2200))\nplt.ylabel('generator power, watts')\nplt.xlabel('RPM')\n\nplt.title('Generator power vs RPM')\nplt.show()\n\n\n\n\n\n\n\n\nDividing power by voltage we can get the current supplied to the load.\n\ngen_rpm_plt = np.linspace(226, 1500, 50)\n\nplt.plot(gen_rpm_plt,(m1*gen_rpm_plt+c1)*(m2*gen_rpm_plt+c2)/(m*gen_rpm_plt+c), '-',label='generator current, Amps')\n\nplt.plot(1500,(m1*1500+c1)*(m2*1500+c2)/(m*1500+c),'or',label = '{:.1f} Amps at 1500 RPM'.format((m1*1500+c1)*(m2*1500+c2)/(m*1500+c)))\nplt.plot(900,(m1*900+c1)*(m2*900+c2)/(m*900+c),'^',label = '{:.1f} Amps at 900 RPM'.format((m1*900+c1)*(m2*900+c2)/(m*900+c)))\nplt.plot(500,(m1*500+c1)*(m2*500+c2)/(m*500+c),'^',label = '{:.1f} Amps at 500 RPM'.format((m1*500+c1)*(m2*500+c2)/(m*500+c)))\nplt.plot(226,(m1*226+c1)*(m2*226+c2)/(m*226+c),'^',label = '{:.1f} Amps at 226 RPM'.format((m1*226+c1)*(m2*226+c2)/(m*226+c)))\n\nplt.legend(bbox_to_anchor=(1.7, 1))\nplt.grid()\n\nplt.ylim((19,26))\nplt.ylabel('generator current, under load')\nplt.xlabel('RPM')\n\nplt.title('Generator current vs RPM')\nplt.show()\n\n\n\n\n\n\n\n\nAssuming that the 500 RPM point is close to the operating point, 20 Amps is available for charging.\nAs described above, I assumed that generator power was linear with RPM and that generator current could then be calculated from the voltage and power with a derating for the lower RPM. I think these calculations are fine, given the limited performance data available for the generator. Also, I wonder about the test conditions for the 12 volts at 266 RPM, 24 volts at 500 RPM and 48 volts at 900 RPM data. 12, 24, and 48 are nominal battery voltages and perhaps the RPM’s quoted are the minimum RPM required to charge 12, 24, or 48 volt batteries.\nI started to derive a set of curves for voltage versus power at select RPM’s; and I found that I was making assumptions on top of assumptions in order to derive the performance curves. So the calculations above have the least amount of assumptions, which is only to assume the relations are linear. In my attempt to derive the generator performance curves, I got the feeling that this generator is not well suited for waterwheel applications. If I were actually doing this hydro project, and I already had the generator in hand having spent about a thousand dollars for it, before proceeding I would build a small generator test stand and collect some measured performance data. I suppose that the non-availability of a datasheet or performance curves should have been a red flag.\n\ngenerator_pwr = 510*ureg.watt\ngenenerator_rpm = 500*ureg.rpm\n\n# convert to base units\ngenerator_pwr.ito_base_units()\ngenenerator_rpm.ito_base_units()\n\n# calculate the generator shaft torque\ngen_tau = generator_pwr/genenerator_rpm\nprint('generator shaft torque, in base units: {:s}'.format(f\"{gen_tau.to_base_units():.1f~P}\"))\nprint('generator shaft torque: {:s}'.format(f\"{gen_tau.to('foot * force_pound'):.1f~P}\"))\n\ngenerator shaft torque, in base units: 9.7 kg·m²/rad/s²\ngenerator shaft torque: 7.2 ft·lbf\n\n\nAs calculated above the generator needs 7.2 ft·lbf of torque at 500 RPM to charge the house batteries."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#pulley-system",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#pulley-system",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Pulley system",
    "text": "Pulley system\nThe purpose of the pulley system is to transform the waterwheel rotations to the generator shaft. Michael said that Jerry did the calculations for the wheel sizes for the pulleys, which he said was a one to eight ratio. The pulley wheel diameters were estimated by looking at the video and doing a relative comparison against the final generator pulley which is advertised to be 3 inches in radius. The formula for pulleys is:\n\\(D_1 \\times RPM_1 = D_2 \\times RPM_2\\)\nwhere \\(D_1\\) and \\(D_2\\) are the pulley diameters and \\(RPM_1\\) and \\(RPM_2\\) are the rotations per minute.\nStarting at the generator, d1 and d2 are the pulleys on the generator belt and rpm1 is what is needed on the generator shaft.\n\nd1 = 3 # diameter of pulley on the generator\nd2 = 8 # diameter of large pulley on middle axle\nrpm1 = 500 # needed at the generator\nrpm2 = d1*rpm1/d2 # at the big wheel on 2nd shaft\nprint('RPM on the middle axle: {:0.1f}'.format(rpm2))\n\nRPM on the middle axle: 187.5\n\n\nThe middle axle has two pulleys, d2, from above and d3; d3 is connected by a second belt to the pulley on the waterwheel shaft, d4.\n\nd3 = 4 # diameter of small pulley on middle axle\nd4 = 12 # diameter of pulley on waterwheel\nrpm3 = d3*rpm2/d4\nprint('RPM on the waterwheel axle: {:0.1f}'.format(rpm3))\nprint('total pulley ratio: {:.1f}:1'.format((d2/d1)*(d4/d3)))\nprint('Torque on the waterwheel axle: {:s}'.format(f\"{(gen_tau*(d2/d1)*(d4/d3)).to('foot * force_pound'):.1f~P}\"))\n\nRPM on the waterwheel axle: 62.5\ntotal pulley ratio: 8.0:1\nTorque on the waterwheel axle: 57.5 ft·lbf\n\n\nThe total ratio for the pulleys is 8:1 and agrees with Michael’s comments in the video. A waterwheel RPM of 62 is needed to spin the generator at 500 RPM, which is too high for the waterwheel. Water will not stay in the buckets at this RPM. Let’s say 10 RPM is more appropriate for the waterwheel, then a pulley or gear ratio of 100 is needed. At a 100:1 ratio, gears are needed, so a planetary type gearbox might work."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#electrical-cable",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#electrical-cable",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Electrical cable",
    "text": "Electrical cable\nElectrical power cables are needed to run from the generator located at the waterwheel up to the cabin, where the charge controller and the batteries are located. The generator makes 3 phase AC and at 400 RPM, the generater produces, let’s say 300W. The cable according to Michael is 10-3, which I take to mean three conductors of 10 AWG wire. Two sets of cables were buried in the ground. Michael said he purchased the cable form Missouri Wind and Solar, but I could not find on their website any information about the type of cable he might have purchased.\nUsing cable specifications from Alpha Wire, M3903 was chosen as a type of cable that has specifications typical for this application. This cable is available in configurations of three or six conductors with multi stranded (7/.0385) 10 AWG bare copper conductors. The conductor DC resistance is 1.03 ohms/1000ft at 20°C (68°F), nominal. The cable has a voltage rating of 600 VRMS, is sunlight resistant and is suitable for direct burial.\nThe voltage drop per conductor for 220 feet of cable run, operating at 30 volts and carrying 500 Watts of power is calculated below. Since the AC frequency of the generator is low, I’m ignoring the AC impedance of the cable and using the RMS voltage to calculate the voltage drop due to the DC resistance in the cable. 30 volts was used in the calculations, since this is probably close to the operating point of the charge controller.\nThe generator frequency is: frequency = RPM * Number of magnetic poles (P) / 120.\n\n# generator AC frequency\nRPM = 500  # RPM\nP = 28*2 # 28 magnets, so number of poles is twice the number of magnets\nprint('generator AC frequency: {:.1f} Hz'.format(RPM*P/120))\n\ngenerator AC frequency: 233.3 Hz\n\n\nAs long as the AC frequency is under 500 Hz and the cable run is less than 500 ft, I would ignore the AC impedance when doing back of the envelope or rough order of magnitude type calculations that engineers like to do. As part of a detailed design, I definitely would look at the impedance of the cable (capacitance 32 pF/ft at 1 kHz and inductance 0.16 μH/ft) to calculate the voltage drop.\nThe resistance per phase for the 220 foot cable run is calculated below.\n\nresistance_per_phase = 1.03*ureg.ohms/(1000*ureg.foot)*220*ureg.feet\nprint('resistance per phase: {:s} at 20 degrees C for 220 ft'.format(f\"{resistance_per_phase:.3f~P}\") )\n\nvolts_per_phase = 30*ureg.volt # rms\nprint('volts per phase: {:s}rms'.format(f\"{volts_per_phase:.1f~P}\") )\n\ncurrent_per_phase = (500*ureg.watt/6/volts_per_phase).to_base_units() # using 6 since there are 6 wires in the system\nprint('current per phase: {:s}rms'.format(f\"{current_per_phase:.2f~P}\") )\n\nvoltage_drop_per_phase = (resistance_per_phase*current_per_phase).to('volts')\nprint('voltage drop per phase: {:s}rms'.format(f\"{voltage_drop_per_phase:.2f~P}\") )\n\nresistance per phase: 0.227 Ω at 20 degrees C for 220 ft\nvolts per phase: 30.0 Vrms\ncurrent per phase: 2.78 Arms\nvoltage drop per phase: 0.63 Vrms\n\n\nA voltage drop of about 0.6 volts to the house when the generator is developing 500 W, is acceptable."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#charge-controller",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#charge-controller",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Charge controller",
    "text": "Charge controller\nThe charge controller is a Midnite Classic 200 which has a price tage of about \\$650, depending on the vendor. The charge controller provides maximum power point tracking (MPPT). MPPT’ers are intelligent DC to DC converters and regulate current and voltage to safely charge batteries.\nI believe that the Midnite Classic 200 needs at least the battery absorption voltage from the generator to charge the batteries. I did not read in the manual that the Midnite Classic 200 was capable of boosting the voltage from the generator to the absorption voltage. This probably means that the generator RPM needs to be a bit higher than 500 RPM.\nI would talk to customer support at Battle Born Batteries and get recommendations for setting up the Midnite Classic 200 for their batteries. The set up for a waterwheel based hydroelectric system might be a little out of the ordinary. Based on the little I know about LiFePO batteries, I would think that you would set up the charge controller to charge in a constant current mode for the required absorption time which the controller would adjust based on available current and state of charge. Also the maximum power point tracking time constant should be set to sweep in intervals of tens of minutes not seconds like it would do for a solar system.\nOnce the hydro generator performance curves are obtained, either from the generator’s manufacture or measured from a test stand, a more detailed evaluation can be performed. I suspect that the operating point for Michael’s hydro system lays on the part of the curve which is above the maximum power point at the operating RPM, since his hydro system will struggle to make the absorption voltage, so MPPT would not be useful."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#after-thoughts",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#after-thoughts",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "After thoughts",
    "text": "After thoughts\nHaving gone through these calculations and doing some reading and research, I realize that there are a lot of trade offs to be made when looking for an optimal solution. I think the flume to battery path needs to be looked at as a system and not as individual parts to be connected together. Reverse engineering Michael’s hydroelectric system was a fun learning experience. The cost of the major components, batteries, generator and charge controller were about \\$7000 dollars. I have no idea how much the dam costs. I certainly would not invest thousands of dollars in a project without a feasibility study and an analysis of alternatives. The extent of Michael’s planning seemed to consist of nothing more than wishful thinking.\nAll the successful micro hydroelectric installations I’ve read about while researching this topic have common characteristics: - a conservative estimated power production of at least 1kW - a return on investment (ROI) not exceeding a few years\nPlanning for micro hydroelectric projects should consider both engineering and economics. If Michael was going to build the dam anyway, and he really wanted a waterwheel, regardless of the ROI, he should have looked into building the largest diameter waterwheel that could have been accommodated at the site, either by excavating a tail race or by moving the supports down stream a bit. A 15 foot diameter wheel could have provided about 1kW from February to June and maybe 250 Watts during the dry season. But a wheel with a 15 foot diameter is big and would have to be assembled on site. Now you’re talking about something requiring planning and forethought. The toy wheel that Jerry built was hopeless from the beginning."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#recommendations-provided-by-joe-malovich",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#recommendations-provided-by-joe-malovich",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Recommendations provided by Joe Malovich",
    "text": "Recommendations provided by Joe Malovich\nA YouTuber named Joe Malovich provided comments and recommendations in [9]. I’ve summarized some of his suggestions:\n- reduce bucket dept - extend mill race past existing stand and get a larger dia wheel - use the hydro function on the charge controller - size of generator - 200 GPM at 7 ft = 250 watts - get solar - conduct due diligence on Missouri Wind and Solar - change to a Pelton system or in-line turbine\nJoe has an interesting set of videos documenting his experiments with micro hydro power here and here."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#system-redesign",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#system-redesign",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "System redesign",
    "text": "System redesign\nI’ll venture down this rabbit hole at some point in the future. I’ll look at two options: 1. Redesign the waterwheel to have larger diameter and width, keep the RPM to about 10 2. Look at a penstock with a Pelton or in-line turbine\nA company called Waterwheel Factory makes waterwheels at their manufacturing facility in Franklin, North Carolina. Prices for a 7 to 10 foot diameter wheel are \\$6K to \\$12K and a 11 to 15 foot diameter wheel are \\$12K to \\$20K.\nOne of the disadvantages of a waterwheel is the low rotational speed which requires gears or pulleys to step up the rotations to a speed required by the generator. Low RPM alternators are not really that low, being 200 to 500 RPM versus the 1500 to 2000 RPM of a normal alternator.\nRunning the calculations with the following efficiencies: - \\(\\eta\\) for waterwheel = 70% - \\(\\eta\\) for generator = 95%\n- \\(\\eta\\) for charge controller = 99%"
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#estimated-power-production-vs-flow-and-height-1",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#estimated-power-production-vs-flow-and-height-1",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "Estimated power production vs flow and height",
    "text": "Estimated power production vs flow and height\n\neta_waterwheel = 0.7 # for a small waterwheel or turbine\neta_generator = 0.95\neta_charge_controller = 0.98\neta_total = eta_waterwheel*eta_generator*eta_charge_controller\n\nflow_rate = np.linspace(50,500,10)*ureg.gal/ureg.min # flow rate range in gallons per minute\nhead_height = np.array([10,15,20,25,30])*ureg.feet # head height, range in feet\n# convert to metric\nQ = flow_rate.to_base_units()\nH = head_height.to_base_units()\n\nfor i in range(len(head_height)):\n    plt.plot(flow_rate.to('gal/min'),(rho*g*Q*H[i]*eta_total).to('watt'),\n        label = 'water head: {:s}'.format(f\"{H[i].to('feet'):.0f~P}\"))\n\nplt.legend(bbox_to_anchor=(1.4, 1))\nplt.grid()\n\nplt.ylim((0,1000))\nplt.xlim((100,500))                                          \nplt.ylabel('electrical power, W')\nplt.xlabel('water flow rate, GPM')\n\nplt.title('Estimated production of hydro power')\nplt.show()\n\n\n\n\n\n\n\n\nThe green line is for 20 feet of water head, which appears sufficient to produce the minimum power needed at minimum water flow."
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#references",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#references",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "References",
    "text": "References\n\nLoftis Party of Six: YouTube, Webpage, Facebook, AirBnB\nBuilding A Dam for Hydroelectric Power - Part 1 - Off Grid Cabin - EP #22, Jul 12, 2020\nFinishing the Dam @ the Off Grid Cabin - Part 2 / EP #23, Jul 16, 2020\nThe Dam is Holding Water!!! & The Off Grid Cabin gets WeBoost / EP #24, Jul 19, 2020\nInstalling the Water Wheel for HYDRO POWER @ the Off Grid Cabin!! EP #25, Jul 26, 2020\nDid we MAKE HYDRO POWER Using Our Waterwheel for Self Reliant Off Grid Living?, Jan 17, 2021\nPossible Hydro Power Solutions for our Off Grid Cabin? A BIG THANKS TO YOU!!, Jan 24, 2021\nIs Our DAM SAFE??? What Happened After a BIG RAIN 🌧!!!, Apr 11, 2021\nFixed Waterwheel Suggestions for Loftis Party of Six - weROAM, Jan 26, 2021,\nMaking old Wagon Wheels into a Water Wheel - Slideshow\nEmanuele Quaranta, Roberto Revelli, Gravity water wheels as a micro hydropower energy source: A review based on historic data, design methods, efficiencies and modern optimizations, Renewable and Sustainable Energy Reviews, Volume 97, 2018"
  },
  {
    "objectID": "Overshot waterwheel hydroelectric power system analysis.html#youtube-comments",
    "href": "Overshot waterwheel hydroelectric power system analysis.html#youtube-comments",
    "title": "Overshot waterwheel hydroelectric power system analysis",
    "section": "YouTube comments",
    "text": "YouTube comments\nI read through quite a few of the comments. Most were supportive and wished Michael success. A handful said only a small amount of power could be harvested from his hydro system. Someone who claimed to be an engineer said that the dam didn’t need any rebar. Others said he needed to switch to AC because everybody knows that DC can’t go as far. One commenter said that beavers build bigger dams and they don’t use rebar, mud and sticks are sufficient.\nI would say that about 90% of the comments which addressed technical topics were absolutely ridiculous and made by people with no science or technical training. Some who had hands on experience offered advice to do what they did because that was what worked for them. But I don’t think any of them had experience with a waterwheel based hydroelectric systems.\nMy favorite comments where these:\nFrom [9], lefou lefoou wrote:\nWow, kudos my friend. You’re very brave with your build and pray strategy. I love it. As you have discovered, what you started is a journey. Now for a build like this one, your initial results are absolutely normal, anything else would of been a miracle. But you did make a huge mistake, and I do believe you realized it. Your biggest mistake was that you did seem to accept defeat in your last video. If you ask me you might have stumbled across the best marketing idea I have seen on YouTube in a long time. When you said in this video that it was strange that most people listen to videos to learn things and in this case your viewers are teaching you. I garentie that if you make this the theme of your YouTube channel and you do it strategically and well you are going to annihilate the YouTube algorithm. The viewers that follow you could become so invested in your success they would become what we call superfans and you would have engagement tru the roof. I would suggest the book ( superfans by pat flynn). Now I’m the complete opposite of you, I dabble in everything, real estate, homesteading, new energies, marketing, etc.. etc.. I learn everything and do nothing. But I really do think you should talk to a really good marketer about this reverse learning YouTube channel idea, I think this could be a gold mine, if done right. I will definitely be following you, I’m really curious where you go from here. Don’t hesitate to reach out. You’re a very interesting fellow.\nFrom [6], Kris Harbour Natural Building wrote:\nHi, One of your subscribers sent me over here to maybe offer some advice. The first thing i notice is you are trying to get to 24v. really you need to be shooting for twice that unloaded as once you load it it will slow down. I think this is the problem you are having as far as voltage. so you need to be looking to get the Alternator up to closer to 50v unloaded or you will just loose all the voltage as soon as its loaded.\nAs far as expectations go. I wouldn’t be counting on more than a few watts from that at the flow. in fact you might even struggle to overcome the losses to get the the voltage at that flow. A water wheel is only about 50% efficient at best and that amount of water wont do much. So in summery. you need more water or more head and to try and get a unloaded free spin voltage of at least twice as much as your system needs so when you load the wheel it will be slowed down to 24v. I see from the clip of it running at 50w the controler had loaded the waterwheel to 40v. That controler isnt really designed for that kind of system. That is the reason it was jumping around when you had 30-50w coming in. It was trying to find the maximum power point. The controler itself uses quite a bit of power just to run and is quite a big loss that you dont need. If you get the wheel to free spin at 50v and then direct connect to your batteries you will take away that loss and as long as your cable is sized properly then you wont loose to much in the cable. That would mean it would not be controlled and could overcharge the batteries but a simple disconnect solenoid would work for that to just cut the incoming power once a set voltage is reached as it would not cause your wheel any problems to free spin. Something like this would work just fine. https://www.ebay.co.uk/itm/10-000-WATT-Battery-Dump-Controller-SOLAR-Wind-Regulator-G4-440-24-VOLT-N/232747971845?hash=item3630dc3505:g:3MsAAOSwZula4ovW The midnite controler is way overkill for a system like that. put some solar panels on that controler and put it to a better use.\nFrom what i can see you only have about 1m of head so here are some numbers for you. After losses in the wheel and cable you would need 25 liters per second (appox 400 gpm) to make 100w at your batteries. And that would be at a system efficiency of 50% witch would be on the high side for a wheel like that.\nAll is not lost with it. small amounts of power over a long period of time are not at all worthless. But you have to keep efficiency in mind so you dont loose it all. So big cables, as few bearings as possible as few belts as possible as few pulleys as possible. And as few controllers as possible. every time you move a part you loose watts of power. But the main issue is lack of flow and losses in the wheel. I would need to know your average flows but it looks to me like with some modifications and changes, like wheel design, cable sizes, and direct drive. you could expect to get a some power from it But unless you have very large flows it really wont ever power the cabin. But even 20w 24h a day is almost 0.5kwh so it could be worth it but i would need some numbers from you.\nThe dam you have and the setup looks like it could run a low head turbine as apposed to a water wheel and i would be happy to advise on that but i would need you to monitor the flows for at least a year first to make sure it was viable and to size it properly. It dose look like that water source goes up higher on your land? how high up dose it go while still on your property? you might have more luck taking the water from there in a pipe down to a small turbine. But again i would need to know the head anf flow number to help with that.\nIf you want any help with it feel free to email me about it at Diyharbor@gmail.com"
  },
  {
    "objectID": "source.html",
    "href": "source.html",
    "title": "Source",
    "section": "",
    "text": "Links to my github page.\n\n\n\nJupyter Nodebook\nLink to Github\n\n\n\n\nSource free series circuit\nlink\n\n\nSciPy analog filter design\nlink\n\n\nOvershot waterwheel hydroelectric power system analysis\nlink\n\n\nLake District Overshot Waterwheel Project Review and Analysis\nlink"
  }
]